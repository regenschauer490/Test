<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>SigUtil: sig Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SigUtil
   &#160;<span id="projectnumber">0.95</span>
   </div>
   <div id="projectbrief">Utility modules for modern C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacesig.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sig Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesig_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_absolute_error.html">AbsoluteError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">誤差基準（絶対誤差）  <a href="structsig_1_1_absolute_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STLライクな静的配列  <a href="classsig_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1assign__div__t.html">assign_div_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">compound_assignment の第1引数に指定する代入関数のプリセット（除算代入）  <a href="structsig_1_1assign__div__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1assign__minus__t.html">assign_minus_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">compound_assignment の第1引数に指定する代入関数のプリセット（減算代入）  <a href="structsig_1_1assign__minus__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1assign__mult__t.html">assign_mult_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">compound_assignment の第1引数に指定する代入関数のプリセット（乗算代入）  <a href="structsig_1_1assign__mult__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1assign__plus__t.html">assign_plus_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">compound_assignment の第1引数に指定する代入関数のプリセット（加算代入）  <a href="structsig_1_1assign__plus__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_binary_distance.html">BinaryDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">バイナリ距離  <a href="structsig_1_1_binary_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_canberra_distance.html">CanberraDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャンベラ距離  <a href="structsig_1_1_canberra_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_cosine_similarity.html">CosineSimilarity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">コサイン類似度（Cosine Similarity）  <a href="structsig_1_1_cosine_similarity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1decrement__t.html">decrement_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数の値をデクリメントした値を返す関数オブジェクト  <a href="structsig_1_1decrement__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1div__t.html">div_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">除法を行う関数オブジェクト  <a href="structsig_1_1div__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1_histgram.html">Histgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ヒストグラム  <a href="classsig_1_1_histgram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1identity__t.html">identity_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数の変数をそのまま返す関数オブジェクト  <a href="structsig_1_1identity__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1increment__t.html">increment_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">引数の値をインクリメントした値を返す関数オブジェクト  <a href="structsig_1_1increment__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_j_s___divergence.html">JS_Divergence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JS情報量（Jensen-Shannon Divergence）  <a href="structsig_1_1_j_s___divergence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_k_l___divergence.html">KL_Divergence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KL情報量（Kullback–Leibler Divergence）  <a href="structsig_1_1_k_l___divergence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_mahalanobis_distance.html">MahalanobisDistance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1_manage_convergence.html">ManageConvergence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">収束判定の計算と管理を行うクラス  <a href="classsig_1_1_manage_convergence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1_manage_convergence_simple.html">ManageConvergenceSimple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">収束判定の管理を行うクラス  <a href="classsig_1_1_manage_convergence_simple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_max_norm.html">MaxNorm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">最大ノルム  <a href="structsig_1_1_max_norm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_minkowski_distance.html">MinkowskiDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ミンコフスキー距離  <a href="structsig_1_1_minkowski_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1minus__t.html">minus_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">減法を行う関数オブジェクト  <a href="structsig_1_1minus__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1mult__t.html">mult_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">乗法を行う関数オブジェクト  <a href="structsig_1_1mult__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_norm.html">Norm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pノルム  <a href="structsig_1_1_norm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1_percent.html">Percent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">パーセント型  <a href="classsig_1_1_percent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1plus__t.html">plus_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">加法を行う関数オブジェクト  <a href="structsig_1_1plus__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsig_1_1_relative_error.html">RelativeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">誤差基準（相対誤差）  <a href="structsig_1_1_relative_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1_simple_random.html">SimpleRandom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">初期化時に指定した範囲の一様分布乱数を発生させるクラス  <a href="classsig_1_1_simple_random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1_tag_dealer.html">TagDealer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HTML風にタグをエンコード・デコードする  <a href="classsig_1_1_tag_dealer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1_time_watch.html">TimeWatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">タイムウォッチ  <a href="classsig_1_1_time_watch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsig_1_1_zen_han_replace.html">ZenHanReplace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">全角・半角文字の置換処理を行う  <a href="classsig_1_1_zen_han_replace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a87fb6486ef20975e88be5c8758e5a8cc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87fb6486ef20975e88be5c8758e5a8cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a> = boost::numeric::ublas::matrix&lt; T &gt;</td></tr>
<tr class="separator:a87fb6486ef20975e88be5c8758e5a8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778d6619d275a84c0214370668335ba3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a778d6619d275a84c0214370668335ba3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a> = boost::numeric::ublas::vector&lt; T &gt;</td></tr>
<tr class="separator:a778d6619d275a84c0214370668335ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2021fa0b889efd4766c666fa312e52c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a2021fa0b889efd4766c666fa312e52c3">ManhattanDistance</a> = <a class="el" href="structsig_1_1_minkowski_distance.html">MinkowskiDistance</a>&lt; 1 &gt;</td></tr>
<tr class="separator:a2021fa0b889efd4766c666fa312e52c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e7da4764bbcbf7c70a300d401c431f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a86e7da4764bbcbf7c70a300d401c431f">EuclideanDistance</a> = <a class="el" href="structsig_1_1_minkowski_distance.html">MinkowskiDistance</a>&lt; 2 &gt;</td></tr>
<tr class="separator:a86e7da4764bbcbf7c70a300d401c431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ec5a8e01f01010a96578cdc817cd26"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac7ec5a8e01f01010a96578cdc817cd26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a> = boost::optional&lt; T &gt;</td></tr>
<tr class="separator:ac7ec5a8e01f01010a96578cdc817cd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5389e85e2d81c2cdb3262b870130b53"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:ac5389e85e2d81c2cdb3262b870130b53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac5389e85e2d81c2cdb3262b870130b53">IfsSelector</a> = typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt; R, std::string, std::ifstream, std::wifstream &gt;::type</td></tr>
<tr class="separator:ac5389e85e2d81c2cdb3262b870130b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6076be9dec1b137e4e5b6651689f654c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">WriteMode</a> { <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>, 
<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d">WriteMode::append</a>, 
<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>, 
<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d">WriteMode::append</a>
 }</td></tr>
<tr class="memdesc:a6076be9dec1b137e4e5b6651689f654c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SaveLine, SaveNum の保存に関する設定  <a href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">More...</a><br /></td></tr>
<tr class="separator:a6076be9dec1b137e4e5b6651689f654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6076be9dec1b137e4e5b6651689f654c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">WriteMode</a> { <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>, 
<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d">WriteMode::append</a>, 
<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>, 
<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d">WriteMode::append</a>
 }</td></tr>
<tr class="separator:a6076be9dec1b137e4e5b6651689f654c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abeda63170c841fbe2a5af92d094ff11b"><td class="memTemplParams" colspan="2">template&lt;class F , class C1 , class C2 , typename std::enable_if&lt; impl::container_traits&lt; C1 &gt;::exist &amp;&amp;impl::container_traits&lt; C2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:abeda63170c841fbe2a5af92d094ff11b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#abeda63170c841fbe2a5af92d094ff11b">compound_assignment</a> (F &amp;&amp;assign_op, C1 &amp;dest, C2 const &amp;src)</td></tr>
<tr class="memdesc:abeda63170c841fbe2a5af92d094ff11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナへの代入演算 (element-wise: container and container)  <a href="#abeda63170c841fbe2a5af92d094ff11b">More...</a><br /></td></tr>
<tr class="separator:abeda63170c841fbe2a5af92d094ff11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3e02fa708a67feecc8f85033565f60"><td class="memTemplParams" colspan="2">template&lt;class F , class C , class T , typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &amp;&amp;!impl::container_traits&lt; T &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:afc3e02fa708a67feecc8f85033565f60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#afc3e02fa708a67feecc8f85033565f60">compound_assignment</a> (F &amp;&amp;assign_op, C &amp;dest, T src)</td></tr>
<tr class="memdesc:afc3e02fa708a67feecc8f85033565f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナへの代入演算 (element-wise: container and scalar)  <a href="#afc3e02fa708a67feecc8f85033565f60">More...</a><br /></td></tr>
<tr class="separator:afc3e02fa708a67feecc8f85033565f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f13a59ba58f7ba6759826a62cff3abc"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class C  = void&gt; </td></tr>
<tr class="memitem:a8f13a59ba58f7ba6759826a62cff3abc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a8f13a59ba58f7ba6759826a62cff3abc">sum</a> (C const &amp;data) -&gt; typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt; R, void, typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::value_type, R &gt;::type</td></tr>
<tr class="memdesc:a8f13a59ba58f7ba6759826a62cff3abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">総和  <a href="#a8f13a59ba58f7ba6759826a62cff3abc">More...</a><br /></td></tr>
<tr class="separator:a8f13a59ba58f7ba6759826a62cff3abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1ba8ea0b1c32132266462a39ebc629"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class C  = void, class Pred  = void&gt; </td></tr>
<tr class="memitem:a6b1ba8ea0b1c32132266462a39ebc629"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a6b1ba8ea0b1c32132266462a39ebc629">sum</a> (C const &amp;data, Pred const &amp;access_func) -&gt; typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt; R, void, decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(access_func, std::declval&lt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::value_type &gt;())), R &gt;::type</td></tr>
<tr class="memdesc:a6b1ba8ea0b1c32132266462a39ebc629"><td class="mdescLeft">&#160;</td><td class="mdescRight">総和  <a href="#a6b1ba8ea0b1c32132266462a39ebc629">More...</a><br /></td></tr>
<tr class="separator:a6b1ba8ea0b1c32132266462a39ebc629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca23a120fd28afdef7ed55b08b10b157"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class CC  = void&gt; </td></tr>
<tr class="memitem:aca23a120fd28afdef7ed55b08b10b157"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aca23a120fd28afdef7ed55b08b10b157">sum_row</a> (CC const &amp;matrix, uint index)</td></tr>
<tr class="memdesc:aca23a120fd28afdef7ed55b08b10b157"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の指定行の総和  <a href="#aca23a120fd28afdef7ed55b08b10b157">More...</a><br /></td></tr>
<tr class="separator:aca23a120fd28afdef7ed55b08b10b157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b16662097ae63858917af5d4a394e1"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class CC  = void&gt; </td></tr>
<tr class="memitem:a27b16662097ae63858917af5d4a394e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a27b16662097ae63858917af5d4a394e1">sum_col</a> (CC const &amp;matrix, uint index)</td></tr>
<tr class="memdesc:a27b16662097ae63858917af5d4a394e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の指定列の総和  <a href="#a27b16662097ae63858917af5d4a394e1">More...</a><br /></td></tr>
<tr class="separator:a27b16662097ae63858917af5d4a394e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f9ef4103b6e5e2d6f961a6e23fd231"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class C  = void&gt; </td></tr>
<tr class="memitem:a74f9ef4103b6e5e2d6f961a6e23fd231"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a74f9ef4103b6e5e2d6f961a6e23fd231">product</a> (C const &amp;data) -&gt; typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt; R, void, typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::value_type, R &gt;::type</td></tr>
<tr class="memdesc:a74f9ef4103b6e5e2d6f961a6e23fd231"><td class="mdescLeft">&#160;</td><td class="mdescRight">総乗  <a href="#a74f9ef4103b6e5e2d6f961a6e23fd231">More...</a><br /></td></tr>
<tr class="separator:a74f9ef4103b6e5e2d6f961a6e23fd231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f38478e2a527b8fa8642ae06bc7345"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class C  = void, class Pred  = void&gt; </td></tr>
<tr class="memitem:a99f38478e2a527b8fa8642ae06bc7345"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a99f38478e2a527b8fa8642ae06bc7345">product</a> (C const &amp;data, Pred const &amp;access_func) -&gt; typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt; R, void, decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(access_func, std::declval&lt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::value_type &gt;())), R &gt;::type</td></tr>
<tr class="memdesc:a99f38478e2a527b8fa8642ae06bc7345"><td class="mdescLeft">&#160;</td><td class="mdescRight">総乗  <a href="#a99f38478e2a527b8fa8642ae06bc7345">More...</a><br /></td></tr>
<tr class="separator:a99f38478e2a527b8fa8642ae06bc7345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68bf1bb02fbb4df60c56a6786559fdb"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class CC  = void&gt; </td></tr>
<tr class="memitem:ad68bf1bb02fbb4df60c56a6786559fdb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ad68bf1bb02fbb4df60c56a6786559fdb">product_row</a> (CC const &amp;matrix, uint index)</td></tr>
<tr class="memdesc:ad68bf1bb02fbb4df60c56a6786559fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の指定行の総乗  <a href="#ad68bf1bb02fbb4df60c56a6786559fdb">More...</a><br /></td></tr>
<tr class="separator:ad68bf1bb02fbb4df60c56a6786559fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a17970188b8db0a2494d6da37ee1fd"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class CC  = void&gt; </td></tr>
<tr class="memitem:a39a17970188b8db0a2494d6da37ee1fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a39a17970188b8db0a2494d6da37ee1fd">product_col</a> (CC const &amp;matrix, uint index)</td></tr>
<tr class="memdesc:a39a17970188b8db0a2494d6da37ee1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の指定列の総乗  <a href="#a39a17970188b8db0a2494d6da37ee1fd">More...</a><br /></td></tr>
<tr class="separator:a39a17970188b8db0a2494d6da37ee1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08872f62c0e8a5c033c8e4276c793ef"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:ac08872f62c0e8a5c033c8e4276c793ef"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac08872f62c0e8a5c033c8e4276c793ef">average</a> (C const &amp;data)</td></tr>
<tr class="memdesc:ac08872f62c0e8a5c033c8e4276c793ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">平均  <a href="#ac08872f62c0e8a5c033c8e4276c793ef">More...</a><br /></td></tr>
<tr class="separator:ac08872f62c0e8a5c033c8e4276c793ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac10ec1306d2bc98582867245269a87d"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:aac10ec1306d2bc98582867245269a87d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aac10ec1306d2bc98582867245269a87d">variance</a> (C const &amp;data)</td></tr>
<tr class="memdesc:aac10ec1306d2bc98582867245269a87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">分散  <a href="#aac10ec1306d2bc98582867245269a87d">More...</a><br /></td></tr>
<tr class="separator:aac10ec1306d2bc98582867245269a87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035b71dfb549484757f7ea4361980db8"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; std::is_floating_point&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a035b71dfb549484757f7ea4361980db8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a035b71dfb549484757f7ea4361980db8">normalize</a> (C &amp;data)</td></tr>
<tr class="memdesc:a035b71dfb549484757f7ea4361980db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化（Normalization）  <a href="#a035b71dfb549484757f7ea4361980db8">More...</a><br /></td></tr>
<tr class="separator:a035b71dfb549484757f7ea4361980db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2a5fbd16f092be471f46c4e801b1e4"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class C  = void&gt; </td></tr>
<tr class="memitem:a9e2a5fbd16f092be471f46c4e801b1e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a9e2a5fbd16f092be471f46c4e801b1e4">normalize</a> (C const &amp;data, int dummy=0) -&gt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::template rebind&lt; R &gt;</td></tr>
<tr class="memdesc:a9e2a5fbd16f092be471f46c4e801b1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">正規化（Normalization）  <a href="#a9e2a5fbd16f092be471f46c4e801b1e4">More...</a><br /></td></tr>
<tr class="separator:a9e2a5fbd16f092be471f46c4e801b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a533edc2e7fb667d02c2d89bd2dfbd"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; std::is_floating_point&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:ab6a533edc2e7fb667d02c2d89bd2dfbd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab6a533edc2e7fb667d02c2d89bd2dfbd">standardize</a> (C &amp;data)</td></tr>
<tr class="memdesc:ab6a533edc2e7fb667d02c2d89bd2dfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">標準化(Standardization)  <a href="#ab6a533edc2e7fb667d02c2d89bd2dfbd">More...</a><br /></td></tr>
<tr class="separator:ab6a533edc2e7fb667d02c2d89bd2dfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2aa381b8a0330d9810b8c625a556b4"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class C  = void&gt; </td></tr>
<tr class="memitem:a0f2aa381b8a0330d9810b8c625a556b4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0f2aa381b8a0330d9810b8c625a556b4">standardize</a> (C const &amp;data, int dummy=0) -&gt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::template rebind&lt; R &gt;</td></tr>
<tr class="memdesc:a0f2aa381b8a0330d9810b8c625a556b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">標準化(Standardization)  <a href="#a0f2aa381b8a0330d9810b8c625a556b4">More...</a><br /></td></tr>
<tr class="separator:a0f2aa381b8a0330d9810b8c625a556b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fc69c56a1b13e60bda99520e131450"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; std::is_floating_point&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:af3fc69c56a1b13e60bda99520e131450"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#af3fc69c56a1b13e60bda99520e131450">normalize_dist</a> (C &amp;data)</td></tr>
<tr class="memdesc:af3fc69c56a1b13e60bda99520e131450"><td class="mdescLeft">&#160;</td><td class="mdescRight">確率分布の正規化  <a href="#af3fc69c56a1b13e60bda99520e131450">More...</a><br /></td></tr>
<tr class="separator:af3fc69c56a1b13e60bda99520e131450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376b90f17fefe3aa21f2f0a6bdb490f1"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class C  = void&gt; </td></tr>
<tr class="memitem:a376b90f17fefe3aa21f2f0a6bdb490f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a376b90f17fefe3aa21f2f0a6bdb490f1">normalize_dist</a> (C const &amp;data, int dummy=0) -&gt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::template rebind&lt; R &gt;</td></tr>
<tr class="memdesc:a376b90f17fefe3aa21f2f0a6bdb490f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">確率分布の正規化  <a href="#a376b90f17fefe3aa21f2f0a6bdb490f1">More...</a><br /></td></tr>
<tr class="separator:a376b90f17fefe3aa21f2f0a6bdb490f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef46d46fcfa19cf6f982cfa76b59cb13"><td class="memTemplParams" colspan="2">template&lt;class OP , class T1 , class T2 , typename std::enable_if&lt; (!impl::container_traits&lt; typename impl::remove_const_reference&lt; T1 &gt;::type &gt;::exist)&amp;&amp;(!impl::container_traits&lt; typename impl::remove_const_reference&lt; T2 &gt;::type &gt;::exist) &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:aef46d46fcfa19cf6f982cfa76b59cb13"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a> (OP &amp;&amp;func, T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; typename <a class="el" href="structsig_1_1impl_1_1remove__const__reference.html">impl::remove_const_reference</a>&lt; decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(std::forward&lt; OP &gt;(func), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))&gt;::type</td></tr>
<tr class="memdesc:aef46d46fcfa19cf6f982cfa76b59cb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">二項演算 (scalar and scalar)  <a href="#aef46d46fcfa19cf6f982cfa76b59cb13">More...</a><br /></td></tr>
<tr class="separator:aef46d46fcfa19cf6f982cfa76b59cb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe70dfe9bde4e26219c60532199b6220"><td class="memTemplParams" colspan="2">template&lt;class OP , class C1 , class C2 , class CR1  = typename impl::remove_const_reference&lt;C1&gt;::type, class CR2  = typename impl::remove_const_reference&lt;C2&gt;::type, class AT1  = typename impl::forward_element&lt;C1&gt;::type, class AT2  = typename impl::forward_element&lt;C2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; CR1 &gt;::exist &amp;&amp;impl::container_traits&lt; CR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:afe70dfe9bde4e26219c60532199b6220"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#afe70dfe9bde4e26219c60532199b6220">binary_operation</a> (OP &amp;&amp;func, C1 &amp;&amp;c1, C2 &amp;&amp;c2) -&gt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; CR1 &gt;::template rebind&lt; typename <a class="el" href="structsig_1_1impl_1_1remove__const__reference.html">impl::remove_const_reference</a>&lt; decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(std::forward&lt; OP &gt;(func), std::declval&lt; AT1 &gt;(), std::declval&lt; AT2 &gt;()))&gt;::type &gt;</td></tr>
<tr class="memdesc:afe70dfe9bde4e26219c60532199b6220"><td class="mdescLeft">&#160;</td><td class="mdescRight">二項演算 (element-wise: container and container)  <a href="#afe70dfe9bde4e26219c60532199b6220">More...</a><br /></td></tr>
<tr class="separator:afe70dfe9bde4e26219c60532199b6220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a576cc7805287c7d80c00d80a4862c"><td class="memTemplParams" colspan="2">template&lt;class OP , class C , class T , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class ET  = typename impl::forward_element&lt;C&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; CR &gt;::exist &amp;&amp;(!impl::container_traits&lt; typename impl::remove_const_reference&lt; T &gt;::type &gt;::exist) &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a93a576cc7805287c7d80c00d80a4862c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a93a576cc7805287c7d80c00d80a4862c">binary_operation</a> (OP &amp;&amp;func, C &amp;&amp;c, T &amp;&amp;v) -&gt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; CR &gt;::template rebind&lt; typename <a class="el" href="structsig_1_1impl_1_1remove__const__reference.html">impl::remove_const_reference</a>&lt; decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(std::forward&lt; OP &gt;(func), std::declval&lt; ET &gt;(), v))&gt;::type &gt;</td></tr>
<tr class="memdesc:a93a576cc7805287c7d80c00d80a4862c"><td class="mdescLeft">&#160;</td><td class="mdescRight">二項演算 (element-wise: container and scalar)  <a href="#a93a576cc7805287c7d80c00d80a4862c">More...</a><br /></td></tr>
<tr class="separator:a93a576cc7805287c7d80c00d80a4862c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afded19a25b0601f23afc985153b0c047"><td class="memTemplParams" colspan="2">template&lt;class OP , class T , class C , class ET  = typename impl::forward_element&lt;C&gt;::type, class CR  = typename impl::remove_const_reference&lt;C&gt;::type, typename std::enable_if&lt; (!impl::container_traits&lt; typename impl::remove_const_reference&lt; T &gt;::type &gt;::exist)&amp;&amp;impl::container_traits&lt; CR &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:afded19a25b0601f23afc985153b0c047"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#afded19a25b0601f23afc985153b0c047">binary_operation</a> (OP &amp;&amp;func, T &amp;&amp;v, C &amp;&amp;c) -&gt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; CR &gt;::template rebind&lt; typename <a class="el" href="structsig_1_1impl_1_1remove__const__reference.html">impl::remove_const_reference</a>&lt; decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(std::forward&lt; OP &gt;(func), v, std::declval&lt; ET &gt;()))&gt;::type &gt;</td></tr>
<tr class="memdesc:afded19a25b0601f23afc985153b0c047"><td class="mdescLeft">&#160;</td><td class="mdescRight">二項演算 (element-wise: scalar and container)  <a href="#afded19a25b0601f23afc985153b0c047">More...</a><br /></td></tr>
<tr class="separator:afded19a25b0601f23afc985153b0c047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7062686052f3b43a56950645e37c1cc5"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a7062686052f3b43a56950645e37c1cc5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a7062686052f3b43a56950645e37c1cc5">plus</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; decltype(<a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a>(<a class="el" href="structsig_1_1plus__t.html">plus_t</a>(), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))</td></tr>
<tr class="separator:a7062686052f3b43a56950645e37c1cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848ae8d0c6c4180fd26010b517996b1d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a848ae8d0c6c4180fd26010b517996b1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a848ae8d0c6c4180fd26010b517996b1d">minus</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; decltype(<a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a>(<a class="el" href="structsig_1_1minus__t.html">minus_t</a>(), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))</td></tr>
<tr class="separator:a848ae8d0c6c4180fd26010b517996b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9164b021578416e243c0d04ef70ba5a3"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a9164b021578416e243c0d04ef70ba5a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a9164b021578416e243c0d04ef70ba5a3">mult</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; decltype(<a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a>(<a class="el" href="structsig_1_1mult__t.html">mult_t</a>(), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))</td></tr>
<tr class="separator:a9164b021578416e243c0d04ef70ba5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4ee53c674e3a308bb58e327eea48a2"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aae4ee53c674e3a308bb58e327eea48a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aae4ee53c674e3a308bb58e327eea48a2">div</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; decltype(<a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a>(<a class="el" href="structsig_1_1div__t.html">div_t</a>(), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))</td></tr>
<tr class="separator:aae4ee53c674e3a308bb58e327eea48a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c59c24b350c339662beca36cae6be4"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class TR1  = typename impl::remove_const_reference&lt;T1&gt;::type, class TR2  = typename impl::remove_const_reference&lt;T2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; TR1 &gt;::exist||impl::container_traits&lt; TR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:ac7c59c24b350c339662beca36cae6be4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac7c59c24b350c339662beca36cae6be4">operator+</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; decltype(<a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a>(<a class="el" href="structsig_1_1plus__t.html">plus_t</a>(), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))</td></tr>
<tr class="separator:ac7c59c24b350c339662beca36cae6be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f667ffc15f6dc1c3d94dc1f36db059"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class TR1  = typename impl::remove_const_reference&lt;T1&gt;::type, class TR2  = typename impl::remove_const_reference&lt;T2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; TR1 &gt;::exist||impl::container_traits&lt; TR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:ab2f667ffc15f6dc1c3d94dc1f36db059"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab2f667ffc15f6dc1c3d94dc1f36db059">operator-</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; decltype(<a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a>(<a class="el" href="structsig_1_1minus__t.html">minus_t</a>(), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))</td></tr>
<tr class="separator:ab2f667ffc15f6dc1c3d94dc1f36db059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec5d9cab44f8397325ecf8b842b26ee"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class TR1  = typename impl::remove_const_reference&lt;T1&gt;::type, class TR2  = typename impl::remove_const_reference&lt;T2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; TR1 &gt;::exist||impl::container_traits&lt; TR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a6ec5d9cab44f8397325ecf8b842b26ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a6ec5d9cab44f8397325ecf8b842b26ee">operator*</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; decltype(<a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a>(<a class="el" href="structsig_1_1mult__t.html">mult_t</a>(), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))</td></tr>
<tr class="separator:a6ec5d9cab44f8397325ecf8b842b26ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7846abe2d5f70e7f7762c35f437d4143"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class TR1  = typename impl::remove_const_reference&lt;T1&gt;::type, class TR2  = typename impl::remove_const_reference&lt;T2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; TR1 &gt;::exist||impl::container_traits&lt; TR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a7846abe2d5f70e7f7762c35f437d4143"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a7846abe2d5f70e7f7762c35f437d4143">operator/</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2) -&gt; decltype(<a class="el" href="namespacesig.html#aef46d46fcfa19cf6f982cfa76b59cb13">binary_operation</a>(<a class="el" href="structsig_1_1div__t.html">div_t</a>(), std::forward&lt; T1 &gt;(v1), std::forward&lt; T2 &gt;(v2)))</td></tr>
<tr class="separator:a7846abe2d5f70e7f7762c35f437d4143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5abdd94c780931a557c8a0ce94f5df3"><td class="memTemplParams" colspan="2">template&lt;class F , class... Cs&gt; </td></tr>
<tr class="memitem:af5abdd94c780931a557c8a0ce94f5df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#af5abdd94c780931a557c8a0ce94f5df3">for_each</a> (F &amp;&amp;func, Cs &amp;&amp;...containers)</td></tr>
<tr class="memdesc:af5abdd94c780931a557c8a0ce94f5df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数コンテナを反復処理  <a href="#af5abdd94c780931a557c8a0ce94f5df3">More...</a><br /></td></tr>
<tr class="separator:af5abdd94c780931a557c8a0ce94f5df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf79f48e708a89d327561f7aa7cf36e4"><td class="memTemplParams" colspan="2">template&lt;class F , class... Cs&gt; </td></tr>
<tr class="memitem:aaf79f48e708a89d327561f7aa7cf36e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aaf79f48e708a89d327561f7aa7cf36e4">for_each</a> (F &amp;&amp;func, int init, Cs &amp;&amp;...containers)</td></tr>
<tr class="memdesc:aaf79f48e708a89d327561f7aa7cf36e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数コンテナを反復処理 (添字変数の利用可)  <a href="#aaf79f48e708a89d327561f7aa7cf36e4">More...</a><br /></td></tr>
<tr class="separator:aaf79f48e708a89d327561f7aa7cf36e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae5dc89c97a55b722f9c2187e1383ac"><td class="memTemplParams" colspan="2">template&lt;class V , class R  = std::vector&lt;typename V::value_type&gt;&gt; </td></tr>
<tr class="memitem:aeae5dc89c97a55b722f9c2187e1383ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aeae5dc89c97a55b722f9c2187e1383ac">from_vector_ublas</a> (V const &amp;vec) -&gt; R</td></tr>
<tr class="memdesc:aeae5dc89c97a55b722f9c2187e1383ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">ublas::vector&lt;T&gt; から STLのvectorへ変換  <a href="#aeae5dc89c97a55b722f9c2187e1383ac">More...</a><br /></td></tr>
<tr class="separator:aeae5dc89c97a55b722f9c2187e1383ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872c65543565cbb8e0b5ac8fbaa5d9d1"><td class="memTemplParams" colspan="2">template&lt;class M , class R  = std::vector&lt;typename M::value_type&gt;&gt; </td></tr>
<tr class="memitem:a872c65543565cbb8e0b5ac8fbaa5d9d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a872c65543565cbb8e0b5ac8fbaa5d9d1">from_matrix_ublas</a> (M const &amp;mat, uint row) -&gt; R</td></tr>
<tr class="memdesc:a872c65543565cbb8e0b5ac8fbaa5d9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ublas::matrix&lt;T&gt; の指定行を STLのvectorへ変換  <a href="#a872c65543565cbb8e0b5ac8fbaa5d9d1">More...</a><br /></td></tr>
<tr class="separator:a872c65543565cbb8e0b5ac8fbaa5d9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d322da9f344715e8b9839dd5704321"><td class="memTemplParams" colspan="2">template&lt;class M , class R  = std::vector&lt;std::vector&lt;typename M::value_type&gt;&gt;&gt; </td></tr>
<tr class="memitem:a11d322da9f344715e8b9839dd5704321"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a11d322da9f344715e8b9839dd5704321">from_matrix_ublas</a> (M const &amp;mat) -&gt; R</td></tr>
<tr class="memdesc:a11d322da9f344715e8b9839dd5704321"><td class="mdescLeft">&#160;</td><td class="mdescRight">ublas::matrix&lt;T&gt; から STLのvectorの2次元配列へ変換  <a href="#a11d322da9f344715e8b9839dd5704321">More...</a><br /></td></tr>
<tr class="separator:a11d322da9f344715e8b9839dd5704321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a2d548e457c7ad412bb13d81336524"><td class="memTemplParams" colspan="2">template&lt;class C , class T  = typename impl::container_traits&lt;C&gt;::value_type&gt; </td></tr>
<tr class="memitem:ad9a2d548e457c7ad412bb13d81336524"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ad9a2d548e457c7ad412bb13d81336524">to_vector_ublas</a> (C const &amp;vec) -&gt; <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ad9a2d548e457c7ad412bb13d81336524"><td class="mdescLeft">&#160;</td><td class="mdescRight">STLのvector から ublas::vector&lt;T&gt; へ変換  <a href="#ad9a2d548e457c7ad412bb13d81336524">More...</a><br /></td></tr>
<tr class="separator:ad9a2d548e457c7ad412bb13d81336524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a78cd3ddfbe0cd7bcc8d8903c004f9f"><td class="memTemplParams" colspan="2">template&lt;class CC , class T  = typename impl::container_traits&lt;typename impl::container_traits&lt;CC&gt;::value_type&gt;::value_type&gt; </td></tr>
<tr class="memitem:a1a78cd3ddfbe0cd7bcc8d8903c004f9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a1a78cd3ddfbe0cd7bcc8d8903c004f9f">to_matrix_ublas</a> (CC const &amp;mat) -&gt; <a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a1a78cd3ddfbe0cd7bcc8d8903c004f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">STLのvectorの2次元配列 から ublas::matrix&lt;T&gt; へ変換  <a href="#a1a78cd3ddfbe0cd7bcc8d8903c004f9f">More...</a><br /></td></tr>
<tr class="separator:a1a78cd3ddfbe0cd7bcc8d8903c004f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daf188e62e3ea0683467a59fb7ec427"><td class="memTemplParams" colspan="2">template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </td></tr>
<tr class="memitem:a6daf188e62e3ea0683467a59fb7ec427"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a6daf188e62e3ea0683467a59fb7ec427">invert_matrix</a> (<a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; T &gt; &amp;&amp;mat) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; <a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; RT &gt;&gt;</td></tr>
<tr class="memdesc:a6daf188e62e3ea0683467a59fb7ec427"><td class="mdescLeft">&#160;</td><td class="mdescRight">逆行列を求める  <a href="#a6daf188e62e3ea0683467a59fb7ec427">More...</a><br /></td></tr>
<tr class="separator:a6daf188e62e3ea0683467a59fb7ec427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7744371e6137a1870712b81789db204f"><td class="memTemplParams" colspan="2">template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </td></tr>
<tr class="memitem:a7744371e6137a1870712b81789db204f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a7744371e6137a1870712b81789db204f">invert_matrix</a> (<a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; T &gt; const &amp;mat) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; <a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; RT &gt;&gt;</td></tr>
<tr class="separator:a7744371e6137a1870712b81789db204f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb981bcfc924c08db74f1ff900e34555"><td class="memTemplParams" colspan="2">template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </td></tr>
<tr class="memitem:acb981bcfc924c08db74f1ff900e34555"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#acb981bcfc924c08db74f1ff900e34555">matrix_vector_solve</a> (<a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; T &gt; &amp;&amp;mat, <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; T &gt; &amp;&amp;vec) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; RT &gt;&gt;</td></tr>
<tr class="memdesc:acb981bcfc924c08db74f1ff900e34555"><td class="mdescLeft">&#160;</td><td class="mdescRight">連立方程式を解く  <a href="#acb981bcfc924c08db74f1ff900e34555">More...</a><br /></td></tr>
<tr class="separator:acb981bcfc924c08db74f1ff900e34555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c5a1934d6c2113643d688acd571e68"><td class="memTemplParams" colspan="2">template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </td></tr>
<tr class="memitem:a59c5a1934d6c2113643d688acd571e68"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a59c5a1934d6c2113643d688acd571e68">matrix_vector_solve</a> (<a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; T &gt; const &amp;mat, <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; T &gt; const &amp;vec) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; RT &gt;&gt;</td></tr>
<tr class="separator:a59c5a1934d6c2113643d688acd571e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5130e58654a9d4e71e90e0b898e5274"><td class="memTemplParams" colspan="2">template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </td></tr>
<tr class="memitem:ae5130e58654a9d4e71e90e0b898e5274"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae5130e58654a9d4e71e90e0b898e5274">matrix_vector_solve</a> (<a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; T &gt; const &amp;mat, <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; T &gt; &amp;&amp;vec) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; RT &gt;&gt;</td></tr>
<tr class="separator:ae5130e58654a9d4e71e90e0b898e5274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ebfe1d6033e95bebbcbc99670e504a"><td class="memTemplParams" colspan="2">template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </td></tr>
<tr class="memitem:ac2ebfe1d6033e95bebbcbc99670e504a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac2ebfe1d6033e95bebbcbc99670e504a">matrix_vector_solve</a> (<a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">matrix_u</a>&lt; T &gt; &amp;&amp;mat, <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; T &gt; const &amp;vec) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">vector_u</a>&lt; RT &gt;&gt;</td></tr>
<tr class="separator:ac2ebfe1d6033e95bebbcbc99670e504a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e485d9f2c529f6307b98b54d0c1b253"><td class="memTemplParams" colspan="2">template&lt;class F , class V &gt; </td></tr>
<tr class="memitem:a0e485d9f2c529f6307b98b54d0c1b253"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0e485d9f2c529f6307b98b54d0c1b253">map_v</a> (F &amp;&amp;func, V &amp;&amp;vec)</td></tr>
<tr class="memdesc:a0e485d9f2c529f6307b98b54d0c1b253"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの全要素に対して、値を返す関数を適用し、その結果のベクトルを返す  <a href="#a0e485d9f2c529f6307b98b54d0c1b253">More...</a><br /></td></tr>
<tr class="separator:a0e485d9f2c529f6307b98b54d0c1b253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaa8a6e1a0434efc742c8ddcc689d16"><td class="memTemplParams" colspan="2">template&lt;class F , class M &gt; </td></tr>
<tr class="memitem:aaeaa8a6e1a0434efc742c8ddcc689d16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aaeaa8a6e1a0434efc742c8ddcc689d16">map_m</a> (F &amp;&amp;func, M &amp;&amp;mat)</td></tr>
<tr class="separator:aaeaa8a6e1a0434efc742c8ddcc689d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fa2c9c6a36079d0a02fda6ecf976a4"><td class="memTemplParams" colspan="2">template&lt;class F , class V , class... Vs&gt; </td></tr>
<tr class="memitem:a86fa2c9c6a36079d0a02fda6ecf976a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a86fa2c9c6a36079d0a02fda6ecf976a4">for_each_v</a> (F &amp;&amp;func, V &amp;vec, Vs &amp;&amp;...vecs)</td></tr>
<tr class="memdesc:a86fa2c9c6a36079d0a02fda6ecf976a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ベクトルの全要素に対して、関数を適用する  <a href="#a86fa2c9c6a36079d0a02fda6ecf976a4">More...</a><br /></td></tr>
<tr class="separator:a86fa2c9c6a36079d0a02fda6ecf976a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dff9939ed9ec88dfe5d130a00996d6"><td class="memTemplParams" colspan="2">template&lt;class F , class M &gt; </td></tr>
<tr class="memitem:a94dff9939ed9ec88dfe5d130a00996d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a94dff9939ed9ec88dfe5d130a00996d6">for_each_m</a> (F &amp;&amp;func, M &amp;mat)</td></tr>
<tr class="memdesc:a94dff9939ed9ec88dfe5d130a00996d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の全要素に対して、代入演算を行う関数を適用する  <a href="#a94dff9939ed9ec88dfe5d130a00996d6">More...</a><br /></td></tr>
<tr class="separator:a94dff9939ed9ec88dfe5d130a00996d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbb5a44357f4b1e66651f58ed4ff872"><td class="memTemplParams" colspan="2">template&lt;class F , class M &gt; </td></tr>
<tr class="memitem:accbb5a44357f4b1e66651f58ed4ff872"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#accbb5a44357f4b1e66651f58ed4ff872">for_diagonal</a> (F &amp;&amp;func, M &amp;mat)</td></tr>
<tr class="memdesc:accbb5a44357f4b1e66651f58ed4ff872"><td class="mdescLeft">&#160;</td><td class="mdescRight">行列の対角要素の対して、代入演算を行う関数を適用する  <a href="#accbb5a44357f4b1e66651f58ed4ff872">More...</a><br /></td></tr>
<tr class="separator:accbb5a44357f4b1e66651f58ed4ff872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f128f0d26540efea0ccda181a8dddd8"><td class="memTemplParams" colspan="2">template&lt;class V , typename std::enable_if&lt; std::is_floating_point&lt; typename V::value_type &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a3f128f0d26540efea0ccda181a8dddd8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a3f128f0d26540efea0ccda181a8dddd8">normalize_dist_v</a> (V &amp;data)</td></tr>
<tr class="separator:a3f128f0d26540efea0ccda181a8dddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae5d5370bbb239dbacf066b0e73607a"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a0ae5d5370bbb239dbacf066b0e73607a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0ae5d5370bbb239dbacf066b0e73607a">normalize_dist_v</a> (V const &amp;data, int dummy=0)</td></tr>
<tr class="separator:a0ae5d5370bbb239dbacf066b0e73607a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52814e765c5470736aaf284cd0d87bba"><td class="memTemplParams" colspan="2">template&lt;class C1 , class C2 &gt; </td></tr>
<tr class="memitem:a52814e765c5470736aaf284cd0d87bba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a52814e765c5470736aaf284cd0d87bba">is_same_size</a> (C1 const &amp;v1, C2 const &amp;v2)</td></tr>
<tr class="separator:a52814e765c5470736aaf284cd0d87bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710d902f8cf49353c7777f88af537c63"><td class="memTemplParams" colspan="2">template&lt;class C1 , class C2 &gt; </td></tr>
<tr class="memitem:a710d902f8cf49353c7777f88af537c63"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a710d902f8cf49353c7777f88af537c63">is_valid_distribution</a> (C1 const &amp;v1, C2 const &amp;v2)</td></tr>
<tr class="memdesc:a710d902f8cf49353c7777f88af537c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">離散確率分布の性質を満たしているか確認  <a href="#a710d902f8cf49353c7777f88af537c63">More...</a><br /></td></tr>
<tr class="separator:a710d902f8cf49353c7777f88af537c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b044b8daf4cb6bde169e41b9a7ac80"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:ac2b044b8daf4cb6bde169e41b9a7ac80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac2b044b8daf4cb6bde169e41b9a7ac80">has_zero</a> (C const &amp;v)</td></tr>
<tr class="memdesc:ac2b044b8daf4cb6bde169e41b9a7ac80"><td class="mdescLeft">&#160;</td><td class="mdescRight">要素の値に0があるか確認  <a href="#ac2b044b8daf4cb6bde169e41b9a7ac80">More...</a><br /></td></tr>
<tr class="separator:ac2b044b8daf4cb6bde169e41b9a7ac80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ba038deca2879296c8a5dfe8c3ed42"><td class="memTemplParams" colspan="2">template&lt;class C1 , class C2 &gt; </td></tr>
<tr class="memitem:a64ba038deca2879296c8a5dfe8c3ed42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a64ba038deca2879296c8a5dfe8c3ed42">is_comparable</a> (C1 const &amp;v1, C2 const &amp;v2, <a class="el" href="structsig_1_1impl_1_1_numeric_vector_tag.html">impl::NumericVectorTag</a>)</td></tr>
<tr class="memdesc:a64ba038deca2879296c8a5dfe8c3ed42"><td class="mdescLeft">&#160;</td><td class="mdescRight">2つのベクトルが比較可能か確認  <a href="#a64ba038deca2879296c8a5dfe8c3ed42">More...</a><br /></td></tr>
<tr class="separator:a64ba038deca2879296c8a5dfe8c3ed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad83f9796b7cc733121dd6bd819f8f1"><td class="memTemplParams" colspan="2">template&lt;class C1 , class C2 &gt; </td></tr>
<tr class="memitem:acad83f9796b7cc733121dd6bd819f8f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#acad83f9796b7cc733121dd6bd819f8f1">is_comparable</a> (C1 const &amp;v1, C2 const &amp;v2, <a class="el" href="structsig_1_1impl_1_1_distribution_tag.html">impl::DistributionTag</a>)</td></tr>
<tr class="memdesc:acad83f9796b7cc733121dd6bd819f8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">2つの確率分布が比較可能か確認  <a href="#acad83f9796b7cc733121dd6bd819f8f1">More...</a><br /></td></tr>
<tr class="separator:acad83f9796b7cc733121dd6bd819f8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0015738aab7a37329d019d4e6cdd231"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a> (FilepassString const &amp;directory_pass, bool const has_slash) -&gt; FilepassString</td></tr>
<tr class="memdesc:ab0015738aab7a37329d019d4e6cdd231"><td class="mdescLeft">&#160;</td><td class="mdescRight">ディレクトリ・ファイルパスの末尾に'/'or'\'があるかチェックし、付けるか外すかどうかを指定して反映  <a href="#ab0015738aab7a37329d019d4e6cdd231">More...</a><br /></td></tr>
<tr class="separator:ab0015738aab7a37329d019d4e6cdd231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42cbe8ff98d33c0fed0272719afab98"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#af42cbe8ff98d33c0fed0272719afab98">get_file_names</a> (FilepassString const &amp;directory_pass, bool hidden_file, std::wstring extension=L&quot;&quot;) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; std::vector&lt; std::wstring &gt;&gt;</td></tr>
<tr class="memdesc:af42cbe8ff98d33c0fed0272719afab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定ディレクトリにあるファイル名を取得  <a href="#af42cbe8ff98d33c0fed0272719afab98">More...</a><br /></td></tr>
<tr class="separator:af42cbe8ff98d33c0fed0272719afab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fc92d32cb757b35820c70eeff4b0a5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a15fc92d32cb757b35820c70eeff4b0a5">get_folder_names</a> (FilepassString const &amp;directory_pass, bool hidden_file) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; std::vector&lt; std::wstring &gt;&gt;</td></tr>
<tr class="memdesc:a15fc92d32cb757b35820c70eeff4b0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定ディレクトリにあるフォルダ名を取得  <a href="#a15fc92d32cb757b35820c70eeff4b0a5">More...</a><br /></td></tr>
<tr class="separator:a15fc92d32cb757b35820c70eeff4b0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645b1356484f8299988517c57d7fcb0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a645b1356484f8299988517c57d7fcb0d">clear_file</a> (FilepassString const &amp;file_pass)</td></tr>
<tr class="memdesc:a645b1356484f8299988517c57d7fcb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイル内容の初期化  <a href="#a645b1356484f8299988517c57d7fcb0d">More...</a><br /></td></tr>
<tr class="separator:a645b1356484f8299988517c57d7fcb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb33b8d1e2904d1507be34b4fc9eb3c"><td class="memTemplParams" colspan="2">template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class ET  = typename impl::forward_element&lt;C&gt;::type&gt; </td></tr>
<tr class="memitem:a2cb33b8d1e2904d1507be34b4fc9eb3c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a2cb33b8d1e2904d1507be34b4fc9eb3c">filter</a> (F &amp;&amp;pred, C &amp;&amp;list)</td></tr>
<tr class="memdesc:a2cb33b8d1e2904d1507be34b4fc9eb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナから指定条件を満たす要素を抽出する  <a href="#a2cb33b8d1e2904d1507be34b4fc9eb3c">More...</a><br /></td></tr>
<tr class="separator:a2cb33b8d1e2904d1507be34b4fc9eb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d443d245a0a734cddc895d8b79a4fd6"><td class="memTemplParams" colspan="2">template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class ET  = typename impl::forward_element&lt;C&gt;::type&gt; </td></tr>
<tr class="memitem:a2d443d245a0a734cddc895d8b79a4fd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a2d443d245a0a734cddc895d8b79a4fd6">filter</a> (F &amp;&amp;pred, int init, C &amp;&amp;list)</td></tr>
<tr class="memdesc:a2d443d245a0a734cddc895d8b79a4fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナから指定条件を満たす要素を抽出する(反復回数を表すindexが利用できる)  <a href="#a2d443d245a0a734cddc895d8b79a4fd6">More...</a><br /></td></tr>
<tr class="separator:a2d443d245a0a734cddc895d8b79a4fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c420275118d8f50ba11bb4edca967a6"><td class="memTemplParams" colspan="2">template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class ET  = typename impl::forward_element&lt;C&gt;::type&gt; </td></tr>
<tr class="memitem:a5c420275118d8f50ba11bb4edca967a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a5c420275118d8f50ba11bb4edca967a6">partition</a> (F &amp;&amp;pred, C &amp;&amp;list)</td></tr>
<tr class="memdesc:a5c420275118d8f50ba11bb4edca967a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナから指定条件を満たす要素とそれ以外の要素とを分離する  <a href="#a5c420275118d8f50ba11bb4edca967a6">More...</a><br /></td></tr>
<tr class="separator:a5c420275118d8f50ba11bb4edca967a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66e7d0f082892a119563d6433ebdd91"><td class="memTemplParams" colspan="2">template&lt;class F , class T , class C &gt; </td></tr>
<tr class="memitem:ae66e7d0f082892a119563d6433ebdd91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae66e7d0f082892a119563d6433ebdd91">foldl</a> (F &amp;&amp;func, T &amp;&amp;init, C &amp;&amp;list)</td></tr>
<tr class="memdesc:ae66e7d0f082892a119563d6433ebdd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナの先頭からたたみ込み  <a href="#ae66e7d0f082892a119563d6433ebdd91">More...</a><br /></td></tr>
<tr class="separator:ae66e7d0f082892a119563d6433ebdd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3014145c596b086b3077e5c23079a5c0"><td class="memTemplParams" colspan="2">template&lt;class F , class T , class C &gt; </td></tr>
<tr class="memitem:a3014145c596b086b3077e5c23079a5c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a3014145c596b086b3077e5c23079a5c0">foldr</a> (F &amp;&amp;func, T &amp;&amp;init, C &amp;&amp;list)</td></tr>
<tr class="memdesc:a3014145c596b086b3077e5c23079a5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナの末尾からたたみ込み  <a href="#a3014145c596b086b3077e5c23079a5c0">More...</a><br /></td></tr>
<tr class="separator:a3014145c596b086b3077e5c23079a5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3170f013606fc56af11041f81580aa"><td class="memTemplParams" colspan="2">template&lt;class F1 , class F2 , class T , class... Cs&gt; </td></tr>
<tr class="memitem:a0b3170f013606fc56af11041f81580aa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0b3170f013606fc56af11041f81580aa">dotProduct</a> (F1 &amp;&amp;fold_func, F2 &amp;&amp;oper_func, T &amp;&amp;init, Cs &amp;&amp;...lists)</td></tr>
<tr class="memdesc:a0b3170f013606fc56af11041f81580aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変長個のコンテナに対して関数適用して結果を集約する関数  <a href="#a0b3170f013606fc56af11041f81580aa">More...</a><br /></td></tr>
<tr class="separator:a0b3170f013606fc56af11041f81580aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef51ae2e65cfa57644f348690cb9efd9"><td class="memTemplParams" colspan="2">template&lt;class F , class C1 , class... Cs&gt; </td></tr>
<tr class="memitem:aef51ae2e65cfa57644f348690cb9efd9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aef51ae2e65cfa57644f348690cb9efd9">variadicZipWith</a> (F &amp;&amp;func, C1 &amp;&amp;list1, Cs &amp;&amp;...lists)</td></tr>
<tr class="memdesc:aef51ae2e65cfa57644f348690cb9efd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">n引数高階関数  <a href="#aef51ae2e65cfa57644f348690cb9efd9">More...</a><br /></td></tr>
<tr class="separator:aef51ae2e65cfa57644f348690cb9efd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97756ac3daaf2bbeb544278148c960a"><td class="memTemplParams" colspan="2">template&lt;class F , class C &gt; </td></tr>
<tr class="memitem:ac97756ac3daaf2bbeb544278148c960a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac97756ac3daaf2bbeb544278148c960a">map</a> (F &amp;&amp;func, C &amp;&amp;list)</td></tr>
<tr class="memdesc:ac97756ac3daaf2bbeb544278148c960a"><td class="mdescLeft">&#160;</td><td class="mdescRight">1引数高階関数  <a href="#ac97756ac3daaf2bbeb544278148c960a">More...</a><br /></td></tr>
<tr class="separator:ac97756ac3daaf2bbeb544278148c960a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80784da68554a79015e7b28c4f3c8166"><td class="memTemplParams" colspan="2">template&lt;class F , class C1 , class C2 &gt; </td></tr>
<tr class="memitem:a80784da68554a79015e7b28c4f3c8166"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a80784da68554a79015e7b28c4f3c8166">zipWith</a> (F &amp;&amp;func, C1 &amp;&amp;list1, C2 &amp;&amp;list2)</td></tr>
<tr class="memdesc:a80784da68554a79015e7b28c4f3c8166"><td class="mdescLeft">&#160;</td><td class="mdescRight">2引数高階関数  <a href="#a80784da68554a79015e7b28c4f3c8166">More...</a><br /></td></tr>
<tr class="separator:a80784da68554a79015e7b28c4f3c8166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d02cbf89795ccd47382f5a7301f9bf"><td class="memTemplParams" colspan="2">template&lt;class T , class C  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a28d02cbf89795ccd47382f5a7301f9bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a28d02cbf89795ccd47382f5a7301f9bf">replicate</a> (uint n, T const &amp;value) -&gt; C</td></tr>
<tr class="memdesc:a28d02cbf89795ccd47382f5a7301f9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">値を複製したコンテナを返す  <a href="#a28d02cbf89795ccd47382f5a7301f9bf">More...</a><br /></td></tr>
<tr class="separator:a28d02cbf89795ccd47382f5a7301f9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b2c2d68fcc2274a922c3ebf2db3135"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a11b2c2d68fcc2274a922c3ebf2db3135"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a11b2c2d68fcc2274a922c3ebf2db3135">reverse</a> (C &amp;&amp;list) -&gt; typename <a class="el" href="structsig_1_1impl_1_1remove__const__reference.html">impl::remove_const_reference</a>&lt; C &gt;::type</td></tr>
<tr class="memdesc:a11b2c2d68fcc2274a922c3ebf2db3135"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナの要素の順番を逆転させたコンテナを返す  <a href="#a11b2c2d68fcc2274a922c3ebf2db3135">More...</a><br /></td></tr>
<tr class="separator:a11b2c2d68fcc2274a922c3ebf2db3135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0983ab48709aa9ac662fb3e950580a0c"><td class="memTemplParams" colspan="2">template&lt;class C , class R  = typename impl::remove_const_reference&lt;C&gt;::type, typename std::enable_if&lt;!impl::static_container_traits&lt; R &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a0983ab48709aa9ac662fb3e950580a0c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0983ab48709aa9ac662fb3e950580a0c">merge</a> (C &amp;&amp;list1, C &amp;&amp;list2) -&gt; R</td></tr>
<tr class="memdesc:a0983ab48709aa9ac662fb3e950580a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナの結合（同じコンテナ型）  <a href="#a0983ab48709aa9ac662fb3e950580a0c">More...</a><br /></td></tr>
<tr class="separator:a0983ab48709aa9ac662fb3e950580a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00eb3681044e6af60a224d97c089920a"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class C1 , class C2 , class CR1  = typename impl::remove_const_reference&lt;C1&gt;::type, class CR2  = typename impl::remove_const_reference&lt;C2&gt;::type, class RT  = typename std::common_type&lt;		typename impl::container_traits&lt;CR1&gt;::value_type,		typename impl::container_traits&lt;CR2&gt;::value_type	&gt;::type, class RR  = typename impl::SameIf&lt;R, void,		typename impl::remove_const_reference&lt; typename impl::container_traits&lt;CR1&gt;::template rebind&lt;RT&gt;&gt;::type,		R	&gt;::type, class AT1  = typename impl::forward_element&lt;C1&gt;::type, class AT2  = typename impl::forward_element&lt;C2&gt;::type, typename std::enable_if&lt;!(impl::static_container_traits&lt; CR1 &gt;::exist)&gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a00eb3681044e6af60a224d97c089920a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a00eb3681044e6af60a224d97c089920a">merge</a> (C1 &amp;&amp;list1, C2 &amp;&amp;list2) -&gt; RR</td></tr>
<tr class="separator:a00eb3681044e6af60a224d97c089920a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b33214c63c54016a89451fa17eae71f"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class SC , class C , class SCR  = typename impl::remove_const_reference&lt;SC&gt;::type, class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class RT  = typename std::common_type&lt;		typename impl::static_container_traits&lt;SCR&gt;::value_type,		typename impl::container_traits&lt;CR&gt;::value_type	&gt;::type, class RR  = typename impl::SameIf&lt;R, void,		typename impl::remove_const_reference&lt; typename impl::container_traits&lt;CR&gt;::template rebind&lt;RT&gt;&gt;::type,		R	&gt;::type, typename std::enable_if&lt; impl::static_container_traits&lt; SCR &gt;::exist &amp;&amp;(!impl::static_container_traits&lt; CR &gt;::exist)&gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a9b33214c63c54016a89451fa17eae71f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a9b33214c63c54016a89451fa17eae71f">merge</a> (SC &amp;&amp;list1, C &amp;&amp;list2) -&gt; RR</td></tr>
<tr class="separator:a9b33214c63c54016a89451fa17eae71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd3d3a7a12295f72fefd798f29f596f"><td class="memTemplParams" colspan="2">template&lt;class R  = void, class SC1 , class SC2 , class SCR1  = typename impl::remove_const_reference&lt;SC1&gt;::type, class SCR2  = typename impl::remove_const_reference&lt;SC2&gt;::type, class RT  = typename std::common_type&lt;		typename impl::static_container_traits&lt;SCR1&gt;::value_type,		typename impl::static_container_traits&lt;SCR2&gt;::value_type	&gt;::type, class RR  = typename impl::SameIf&lt;R, void,		typename impl::static_container_traits&lt;SCR1&gt;::template rebind_t&lt;RT, impl::plus_t&lt;impl::static_container_traits&lt;SCR1&gt;::size, impl::static_container_traits&lt;SCR2&gt;::size&gt;::value&gt;,		R	&gt;::type, typename std::enable_if&lt; impl::static_container_traits&lt; SCR1 &gt;::exist &amp;&amp;impl::static_container_traits&lt; SCR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:aedd3d3a7a12295f72fefd798f29f596f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aedd3d3a7a12295f72fefd798f29f596f">merge</a> (SC1 &amp;&amp;list1, SC2 &amp;&amp;list2) -&gt; RR</td></tr>
<tr class="separator:aedd3d3a7a12295f72fefd798f29f596f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e732db836fd6424e647a28235c88b8"><td class="memTemplParams" colspan="2">template&lt;class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type&gt; </td></tr>
<tr class="memitem:a54e732db836fd6424e647a28235c88b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a54e732db836fd6424e647a28235c88b8">take</a> (uint n, C &amp;&amp;list) -&gt; CR</td></tr>
<tr class="memdesc:a54e732db836fd6424e647a28235c88b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナの先頭からn個の要素を取り出す  <a href="#a54e732db836fd6424e647a28235c88b8">More...</a><br /></td></tr>
<tr class="separator:a54e732db836fd6424e647a28235c88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b5b129dc12b56daaaf61461e2917d8"><td class="memTemplParams" colspan="2">template&lt;class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type&gt; </td></tr>
<tr class="memitem:a10b5b129dc12b56daaaf61461e2917d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a10b5b129dc12b56daaaf61461e2917d8">drop</a> (uint n, C &amp;&amp;list) -&gt; CR</td></tr>
<tr class="memdesc:a10b5b129dc12b56daaaf61461e2917d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナの先頭からn個を削除したコンテナを返す  <a href="#a10b5b129dc12b56daaaf61461e2917d8">More...</a><br /></td></tr>
<tr class="separator:a10b5b129dc12b56daaaf61461e2917d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef44f1b5b838fe9f968c3c60a95a396d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class TC  = typename std::common_type&lt;T1, T2&gt;::type, class C  = std::vector&lt;TC&gt;&gt; </td></tr>
<tr class="memitem:aef44f1b5b838fe9f968c3c60a95a396d"><td class="memTemplItemLeft" align="right" valign="top">C&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aef44f1b5b838fe9f968c3c60a95a396d">seqn</a> (T1 st, T2 d, uint n)</td></tr>
<tr class="memdesc:aef44f1b5b838fe9f968c3c60a95a396d"><td class="mdescLeft">&#160;</td><td class="mdescRight">等差数列  <a href="#aef44f1b5b838fe9f968c3c60a95a396d">More...</a><br /></td></tr>
<tr class="separator:aef44f1b5b838fe9f968c3c60a95a396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a19163574c5211027fbf97f8933e113"><td class="memTemplParams" colspan="2">template&lt;class... Cs&gt; </td></tr>
<tr class="memitem:a1a19163574c5211027fbf97f8933e113"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a1a19163574c5211027fbf97f8933e113">zip</a> (Cs &amp;&amp;...lists)</td></tr>
<tr class="memdesc:a1a19163574c5211027fbf97f8933e113"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数のコンテナから、タプルのコンテナを作る  <a href="#a1a19163574c5211027fbf97f8933e113">More...</a><br /></td></tr>
<tr class="separator:a1a19163574c5211027fbf97f8933e113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5842dff6397dadbdb09a880b609d0ac"><td class="memTemplParams" colspan="2">template&lt;uint Index, class CT , class T  = typename std::tuple_element&lt;Index, typename impl::container_traits&lt;typename impl::remove_const_reference&lt;CT&gt;::type&gt;::value_type&gt;::type, class R  = std::vector&lt;T&gt;&gt; </td></tr>
<tr class="memitem:af5842dff6397dadbdb09a880b609d0ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#af5842dff6397dadbdb09a880b609d0ac">unzip</a> (CT &amp;&amp;list_tuple) -&gt; R</td></tr>
<tr class="memdesc:af5842dff6397dadbdb09a880b609d0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">タプルのコンテナから、指定したindexのコンテナを取り出す  <a href="#af5842dff6397dadbdb09a880b609d0ac">More...</a><br /></td></tr>
<tr class="separator:af5842dff6397dadbdb09a880b609d0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9514aaa85cf0247a5b08361d22723bf0"><td class="memTemplParams" colspan="2">template&lt;class CT &gt; </td></tr>
<tr class="memitem:a9514aaa85cf0247a5b08361d22723bf0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a9514aaa85cf0247a5b08361d22723bf0">unzip</a> (CT &amp;&amp;c_tuple)</td></tr>
<tr class="memdesc:a9514aaa85cf0247a5b08361d22723bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">タプルのコンテナから、コンテナのタプルを作る  <a href="#a9514aaa85cf0247a5b08361d22723bf0">More...</a><br /></td></tr>
<tr class="separator:a9514aaa85cf0247a5b08361d22723bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d6496e85265c98d7abeb0d76102576"><td class="memTemplParams" colspan="2">template&lt;class C , class F , class... Its&gt; </td></tr>
<tr class="memitem:a41d6496e85265c98d7abeb0d76102576"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a41d6496e85265c98d7abeb0d76102576">iterative_make</a> (uint loop, C &amp;dest, F &amp;&amp;func, Its...iterators)</td></tr>
<tr class="separator:a41d6496e85265c98d7abeb0d76102576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c977dd2ef479d3f036f578b97a22670"><td class="memTemplParams" colspan="2">template&lt;class T , class F1 , class F2 , class... Its&gt; </td></tr>
<tr class="memitem:a9c977dd2ef479d3f036f578b97a22670"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a9c977dd2ef479d3f036f578b97a22670">iterative_fold</a> (uint loop, T &amp;dest, F1 &amp;&amp;<a class="el" href="namespacesig.html#a1a19163574c5211027fbf97f8933e113">zip</a>, F2 &amp;&amp;fold, Its...iterators)</td></tr>
<tr class="separator:a9c977dd2ef479d3f036f578b97a22670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42789077fe53ae36d43aaa4fc60c5e51"><td class="memTemplParams" colspan="2">template&lt;class F , class... Its&gt; </td></tr>
<tr class="memitem:a42789077fe53ae36d43aaa4fc60c5e51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a42789077fe53ae36d43aaa4fc60c5e51">iterative_assign</a> (uint loop, F &amp;&amp;func, Its...iterators)</td></tr>
<tr class="separator:a42789077fe53ae36d43aaa4fc60c5e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0534a7c631ef0cf5355d7feb38b1c5dd"><td class="memTemplParams" colspan="2">template&lt;class F , class... Its&gt; </td></tr>
<tr class="memitem:a0534a7c631ef0cf5355d7feb38b1c5dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0534a7c631ef0cf5355d7feb38b1c5dd">iterative_assign</a> (uint loop, int init, F &amp;&amp;func, Its...iterators)</td></tr>
<tr class="separator:a0534a7c631ef0cf5355d7feb38b1c5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1071fa1cfcfea2462228c6d77d819a9f"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a1071fa1cfcfea2462228c6d77d819a9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a1071fa1cfcfea2462228c6d77d819a9f">erase</a> (C &amp;container, typename <a class="el" href="structsig_1_1impl_1_1sequence__container__traits.html">impl::sequence_container_traits</a>&lt; C &gt;::value_type const &amp;t)</td></tr>
<tr class="separator:a1071fa1cfcfea2462228c6d77d819a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0ca470394d270e10e30e5f5479a7b9"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a2b0ca470394d270e10e30e5f5479a7b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a2b0ca470394d270e10e30e5f5479a7b9">erase</a> (C &amp;container, typename <a class="el" href="structsig_1_1impl_1_1associative__container__traits.html">impl::associative_container_traits</a>&lt; C &gt;::value_type const &amp;t)</td></tr>
<tr class="separator:a2b0ca470394d270e10e30e5f5479a7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3223517453f819a6838eeab4cc797da"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:ab3223517453f819a6838eeab4cc797da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab3223517453f819a6838eeab4cc797da">erase</a> (C &amp;container, typename <a class="el" href="structsig_1_1impl_1_1hash__container__traits.html">impl::hash_container_traits</a>&lt; C &gt;::value_type const &amp;t)</td></tr>
<tr class="separator:ab3223517453f819a6838eeab4cc797da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baf963f8dca01b87498bc2b4026eac0"><td class="memTemplParams" colspan="2">template&lt;class C , class F , typename std::enable_if&lt; impl::sequence_container_traits&lt; C &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a2baf963f8dca01b87498bc2b4026eac0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a2baf963f8dca01b87498bc2b4026eac0">erase_if</a> (C &amp;container, F const &amp;remove_pred)</td></tr>
<tr class="separator:a2baf963f8dca01b87498bc2b4026eac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb3d39faa9c144155f7d78c4a33ddbe"><td class="memTemplParams" colspan="2">template&lt;class RC , class C &gt; </td></tr>
<tr class="memitem:a3cb3d39faa9c144155f7d78c4a33ddbe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a3cb3d39faa9c144155f7d78c4a33ddbe">copy</a> (C &amp;&amp;src) -&gt; RC</td></tr>
<tr class="memdesc:a3cb3d39faa9c144155f7d78c4a33ddbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">別の種類のコンテナに要素をコピーする  <a href="#a3cb3d39faa9c144155f7d78c4a33ddbe">More...</a><br /></td></tr>
<tr class="separator:a3cb3d39faa9c144155f7d78c4a33ddbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ebd0df3cc83f534a217a21267e388a"><td class="memTemplParams" colspan="2">template&lt;class B &gt; </td></tr>
<tr class="memitem:ae5ebd0df3cc83f534a217a21267e388a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae5ebd0df3cc83f534a217a21267e388a">And</a> (B &amp;&amp;cond)</td></tr>
<tr class="separator:ae5ebd0df3cc83f534a217a21267e388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97a9bf9ace305f1a6f67db5b9e3ff35"><td class="memTemplParams" colspan="2">template&lt;class B1 , class... Bs&gt; </td></tr>
<tr class="memitem:af97a9bf9ace305f1a6f67db5b9e3ff35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#af97a9bf9ace305f1a6f67db5b9e3ff35">And</a> (B1 &amp;&amp;cond, Bs &amp;&amp;...conds)</td></tr>
<tr class="memdesc:af97a9bf9ace305f1a6f67db5b9e3ff35"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変長 and  <a href="#af97a9bf9ace305f1a6f67db5b9e3ff35">More...</a><br /></td></tr>
<tr class="separator:af97a9bf9ace305f1a6f67db5b9e3ff35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38045b9fb9540aafd0cec2c698921e6"><td class="memTemplParams" colspan="2">template&lt;class B &gt; </td></tr>
<tr class="memitem:aa38045b9fb9540aafd0cec2c698921e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aa38045b9fb9540aafd0cec2c698921e6">Or</a> (B &amp;&amp;cond)</td></tr>
<tr class="separator:aa38045b9fb9540aafd0cec2c698921e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2b562fa40201017e304a89aaa2d3db"><td class="memTemplParams" colspan="2">template&lt;class B1 , class... Bs&gt; </td></tr>
<tr class="memitem:a8c2b562fa40201017e304a89aaa2d3db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a8c2b562fa40201017e304a89aaa2d3db">Or</a> (B1 &amp;&amp;cond, Bs &amp;&amp;...conds)</td></tr>
<tr class="memdesc:a8c2b562fa40201017e304a89aaa2d3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変長 or  <a href="#a8c2b562fa40201017e304a89aaa2d3db">More...</a><br /></td></tr>
<tr class="separator:a8c2b562fa40201017e304a89aaa2d3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b35af07f2be1e569af810f7b8ac1f2"><td class="memTemplParams" colspan="2">template&lt;class B1 , class B2 &gt; </td></tr>
<tr class="memitem:aa7b35af07f2be1e569af810f7b8ac1f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aa7b35af07f2be1e569af810f7b8ac1f2">Xor</a> (B1 &amp;&amp;a, B2 &amp;&amp;b)</td></tr>
<tr class="memdesc:aa7b35af07f2be1e569af810f7b8ac1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">xor  <a href="#aa7b35af07f2be1e569af810f7b8ac1f2">More...</a><br /></td></tr>
<tr class="separator:aa7b35af07f2be1e569af810f7b8ac1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3dcdb16ea8594712d59f1d088a9db"><td class="memTemplParams" colspan="2">template&lt;class B1 , class B2 &gt; </td></tr>
<tr class="memitem:aebb3dcdb16ea8594712d59f1d088a9db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aebb3dcdb16ea8594712d59f1d088a9db">Consistency</a> (B1 &amp;&amp;a, B2 &amp;&amp;b)</td></tr>
<tr class="memdesc:aebb3dcdb16ea8594712d59f1d088a9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">AとBの真偽一致でtrueを返す (⇔ !xor)  <a href="#aebb3dcdb16ea8594712d59f1d088a9db">More...</a><br /></td></tr>
<tr class="separator:aebb3dcdb16ea8594712d59f1d088a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c7cfeba4eb923ac22a289dccbef2a1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a45c7cfeba4eb923ac22a289dccbef2a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a45c7cfeba4eb923ac22a289dccbef2a1">min</a> (T v) -&gt; T</td></tr>
<tr class="separator:a45c7cfeba4eb923ac22a289dccbef2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac92ca8f4e406fbfe25b85b81152a88"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:aaac92ca8f4e406fbfe25b85b81152a88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aaac92ca8f4e406fbfe25b85b81152a88">min</a> (T1 v1, T2 v2)</td></tr>
<tr class="separator:aaac92ca8f4e406fbfe25b85b81152a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff29c80135045f3ad2a7bd1e148cd0b0"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:aff29c80135045f3ad2a7bd1e148cd0b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aff29c80135045f3ad2a7bd1e148cd0b0">min</a> (T v, Ts...vs)</td></tr>
<tr class="memdesc:aff29c80135045f3ad2a7bd1e148cd0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変長 min  <a href="#aff29c80135045f3ad2a7bd1e148cd0b0">More...</a><br /></td></tr>
<tr class="separator:aff29c80135045f3ad2a7bd1e148cd0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab27dcfc67c86de4742fb2879c566805"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aab27dcfc67c86de4742fb2879c566805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aab27dcfc67c86de4742fb2879c566805">max</a> (T v) -&gt; T</td></tr>
<tr class="separator:aab27dcfc67c86de4742fb2879c566805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316477a2011e24c3ac76d177da8892e2"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a316477a2011e24c3ac76d177da8892e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a316477a2011e24c3ac76d177da8892e2">max</a> (T1 v1, T2 v2)</td></tr>
<tr class="separator:a316477a2011e24c3ac76d177da8892e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf056a93660f704250522f3a38ce08a"><td class="memTemplParams" colspan="2">template&lt;class T , class... Ts&gt; </td></tr>
<tr class="memitem:a2bf056a93660f704250522f3a38ce08a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a2bf056a93660f704250522f3a38ce08a">max</a> (T v, Ts...vs)</td></tr>
<tr class="memdesc:a2bf056a93660f704250522f3a38ce08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">可変長 max  <a href="#a2bf056a93660f704250522f3a38ce08a">More...</a><br /></td></tr>
<tr class="separator:a2bf056a93660f704250522f3a38ce08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c4ff79023e00971f8e168cca5f9abf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab6c4ff79023e00971f8e168cca5f9abf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab6c4ff79023e00971f8e168cca5f9abf">is_number</a> (T x)</td></tr>
<tr class="memdesc:ab6c4ff79023e00971f8e168cca5f9abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">値が非数(NaN)でないかを確認  <a href="#ab6c4ff79023e00971f8e168cca5f9abf">More...</a><br /></td></tr>
<tr class="separator:ab6c4ff79023e00971f8e168cca5f9abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad899ab2bb7357039a1201c7b8d55837a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad899ab2bb7357039a1201c7b8d55837a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ad899ab2bb7357039a1201c7b8d55837a">is_finite_number</a> (T x)</td></tr>
<tr class="memdesc:ad899ab2bb7357039a1201c7b8d55837a"><td class="mdescLeft">&#160;</td><td class="mdescRight">値が非数(NaN)でなく、かつ無限大(Inf)でないかを確認  <a href="#ad899ab2bb7357039a1201c7b8d55837a">More...</a><br /></td></tr>
<tr class="separator:ad899ab2bb7357039a1201c7b8d55837a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0eb27ca84afdbec45509d56c9a555f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab0eb27ca84afdbec45509d56c9a555f4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab0eb27ca84afdbec45509d56c9a555f4">abs_delta</a> (T v1, T v2)</td></tr>
<tr class="separator:ab0eb27ca84afdbec45509d56c9a555f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31b064bc840051da0ef1c67fed91662"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:af31b064bc840051da0ef1c67fed91662"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#af31b064bc840051da0ef1c67fed91662">abs_delta</a> (T1 v1, T2 v2) -&gt; decltype(v1&lt; v2?v2-v1:v1-v2)</td></tr>
<tr class="memdesc:af31b064bc840051da0ef1c67fed91662"><td class="mdescLeft">&#160;</td><td class="mdescRight">2変数の差の絶対値を返す  <a href="#af31b064bc840051da0ef1c67fed91662">More...</a><br /></td></tr>
<tr class="separator:af31b064bc840051da0ef1c67fed91662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3f9d9c09ab0c38afaeafcdd66adb27"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , typename std::enable_if&lt;!(impl::is_string&lt; T1 &gt;::value||impl::is_string&lt; T2 &gt;::value)&gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a1f3f9d9c09ab0c38afaeafcdd66adb27"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a1f3f9d9c09ab0c38afaeafcdd66adb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">数値の簡易等値比較（厳密な計算でない場合の使用を想定）  <a href="#a1f3f9d9c09ab0c38afaeafcdd66adb27">More...</a><br /></td></tr>
<tr class="separator:a1f3f9d9c09ab0c38afaeafcdd66adb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8ce81f827b4b3ac6147aafc4a7d410"><td class="memTemplParams" colspan="2">template&lt;class S1 , class S2 , typename std::enable_if&lt;(impl::is_string&lt; S1 &gt;::value &amp;&amp;impl::is_string&lt; S2 &gt;::value)&gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a4e8ce81f827b4b3ac6147aafc4a7d410"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a4e8ce81f827b4b3ac6147aafc4a7d410">equal</a> (S1 &amp;&amp;v1, S2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a4e8ce81f827b4b3ac6147aafc4a7d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列の等値比較  <a href="#a4e8ce81f827b4b3ac6147aafc4a7d410">More...</a><br /></td></tr>
<tr class="separator:a4e8ce81f827b4b3ac6147aafc4a7d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd502a09c7dcf0affc2be0850b821a28"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:afd502a09c7dcf0affc2be0850b821a28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#afd502a09c7dcf0affc2be0850b821a28">equal_tolerant</a> (T1 v1, T2 v2, typename std::common_type&lt; T1, T2 &gt;::type margin)</td></tr>
<tr class="memdesc:afd502a09c7dcf0affc2be0850b821a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">指定範囲内の誤差を許した等値比較  <a href="#afd502a09c7dcf0affc2be0850b821a28">More...</a><br /></td></tr>
<tr class="separator:afd502a09c7dcf0affc2be0850b821a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959750718a766b4dfde00851301c4df3"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a959750718a766b4dfde00851301c4df3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a959750718a766b4dfde00851301c4df3">check_range</a> (T const &amp;val, U const &amp;<a class="el" href="namespacesig.html#a45c7cfeba4eb923ac22a289dccbef2a1">min</a>, U const &amp;<a class="el" href="namespacesig.html#aab27dcfc67c86de4742fb2879c566805">max</a>)</td></tr>
<tr class="memdesc:a959750718a766b4dfde00851301c4df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">値の範囲チェック  <a href="#a959750718a766b4dfde00851301c4df3">More...</a><br /></td></tr>
<tr class="separator:a959750718a766b4dfde00851301c4df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2759ddda5fc4a3f04dddb08c2b6f7926"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a2759ddda5fc4a3f04dddb08c2b6f7926"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a2759ddda5fc4a3f04dddb08c2b6f7926">modify_range</a> (T &amp;val, U const &amp;<a class="el" href="namespacesig.html#a45c7cfeba4eb923ac22a289dccbef2a1">min</a>, U const &amp;<a class="el" href="namespacesig.html#aab27dcfc67c86de4742fb2879c566805">max</a>)</td></tr>
<tr class="memdesc:a2759ddda5fc4a3f04dddb08c2b6f7926"><td class="mdescLeft">&#160;</td><td class="mdescRight">値を範囲内に自動修正  <a href="#a2759ddda5fc4a3f04dddb08c2b6f7926">More...</a><br /></td></tr>
<tr class="separator:a2759ddda5fc4a3f04dddb08c2b6f7926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecfcffc04df3603a6fd003dd2c11bf6"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:acecfcffc04df3603a6fd003dd2c11bf6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#acecfcffc04df3603a6fd003dd2c11bf6">greater</a> (T1 v1, T2 v2)</td></tr>
<tr class="separator:acecfcffc04df3603a6fd003dd2c11bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd23e1f1e05a7d8abb0555fe019f2460"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:afd23e1f1e05a7d8abb0555fe019f2460"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#afd23e1f1e05a7d8abb0555fe019f2460">less</a> (T1 v1, T2 v2)</td></tr>
<tr class="separator:afd23e1f1e05a7d8abb0555fe019f2460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fafa5a56df7a8b5e949ee830ef2999c"><td class="memTemplParams" colspan="2">template&lt;class T , class R  = typename sig::impl::remove_const_reference&lt;T&gt;::type&gt; </td></tr>
<tr class="memitem:a1fafa5a56df7a8b5e949ee830ef2999c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">Just</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:a1fafa5a56df7a8b5e949ee830ef2999c"><td class="mdescLeft">&#160;</td><td class="mdescRight">値コンストラクタ  <a href="#a1fafa5a56df7a8b5e949ee830ef2999c">More...</a><br /></td></tr>
<tr class="separator:a1fafa5a56df7a8b5e949ee830ef2999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f0cba1ae0e36816871c69a0d7ea931"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a55f0cba1ae0e36816871c69a0d7ea931"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a55f0cba1ae0e36816871c69a0d7ea931">Just</a> (T const &amp;v)</td></tr>
<tr class="separator:a55f0cba1ae0e36816871c69a0d7ea931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cb201c09c499316f1bad72f8373a16"><td class="memTemplParams" colspan="2">template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:a25cb201c09c499316f1bad72f8373a16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a25cb201c09c499316f1bad72f8373a16">Nothing</a> () -&gt; typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt; T, void, typename boost::none_t, <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt;&gt;::type</td></tr>
<tr class="memdesc:a25cb201c09c499316f1bad72f8373a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">値コンストラクタ  <a href="#a25cb201c09c499316f1bad72f8373a16">More...</a><br /></td></tr>
<tr class="separator:a25cb201c09c499316f1bad72f8373a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd20c41ef1171b5379b5e6261be017a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9fd20c41ef1171b5379b5e6261be017a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a9fd20c41ef1171b5379b5e6261be017a">Nothing</a> (T const &amp;dummy) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a9fd20c41ef1171b5379b5e6261be017a"><td class="mdescLeft">&#160;</td><td class="mdescRight">値コンストラクタ  <a href="#a9fd20c41ef1171b5379b5e6261be017a">More...</a><br /></td></tr>
<tr class="separator:a9fd20c41ef1171b5379b5e6261be017a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675208b02facbcec0e0d33e2749494e1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a675208b02facbcec0e0d33e2749494e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a675208b02facbcec0e0d33e2749494e1">isJust</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; const &amp;m)</td></tr>
<tr class="memdesc:a675208b02facbcec0e0d33e2749494e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Justであるか調べる関数．Maybe a -&gt; Bool.  <a href="#a675208b02facbcec0e0d33e2749494e1">More...</a><br /></td></tr>
<tr class="separator:a675208b02facbcec0e0d33e2749494e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa56e575f888c003428d605f6b2f0bb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aeaa56e575f888c003428d605f6b2f0bb">isJust</a> (boost::none_t m)</td></tr>
<tr class="separator:aeaa56e575f888c003428d605f6b2f0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf53abaf9b45b9d4f47c88ef413c9163"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acf53abaf9b45b9d4f47c88ef413c9163"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#acf53abaf9b45b9d4f47c88ef413c9163">isNothing</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; const &amp;m)</td></tr>
<tr class="memdesc:acf53abaf9b45b9d4f47c88ef413c9163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nothingであるか調べる関数．Maybe a -&gt; Bool.  <a href="#acf53abaf9b45b9d4f47c88ef413c9163">More...</a><br /></td></tr>
<tr class="separator:acf53abaf9b45b9d4f47c88ef413c9163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca826f173fe26af455e4e6235d6f357c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aca826f173fe26af455e4e6235d6f357c">isNothing</a> (boost::none_t m)</td></tr>
<tr class="separator:aca826f173fe26af455e4e6235d6f357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f20e072bf9d74747a86b1e966cbc75b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7f20e072bf9d74747a86b1e966cbc75b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a7f20e072bf9d74747a86b1e966cbc75b">fromJust</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a7f20e072bf9d74747a86b1e966cbc75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Justから値を取り出す関数．Maybe a -&gt; a.  <a href="#a7f20e072bf9d74747a86b1e966cbc75b">More...</a><br /></td></tr>
<tr class="separator:a7f20e072bf9d74747a86b1e966cbc75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba761c62ff7410bc36ba4125fc52a9b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3ba761c62ff7410bc36ba4125fc52a9b"><td class="memTemplItemLeft" align="right" valign="top">T const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a3ba761c62ff7410bc36ba4125fc52a9b">fromJust</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; const &amp;m)</td></tr>
<tr class="separator:a3ba761c62ff7410bc36ba4125fc52a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c9838fe59cffe3c0e4eadaffaa10ab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a53c9838fe59cffe3c0e4eadaffaa10ab"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a53c9838fe59cffe3c0e4eadaffaa10ab">fromJust</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; &amp;&amp;m)</td></tr>
<tr class="separator:a53c9838fe59cffe3c0e4eadaffaa10ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2258dc44d08856ce1045788dba03cf0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2258dc44d08856ce1045788dba03cf0"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae2258dc44d08856ce1045788dba03cf0">operator*</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:ae2258dc44d08856ce1045788dba03cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">fromJust演算子  <a href="#ae2258dc44d08856ce1045788dba03cf0">More...</a><br /></td></tr>
<tr class="separator:ae2258dc44d08856ce1045788dba03cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f93b97f665d79e5896411aab6eefe59"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5f93b97f665d79e5896411aab6eefe59"><td class="memTemplItemLeft" align="right" valign="top">T const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a5f93b97f665d79e5896411aab6eefe59">operator*</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; const &amp;m)</td></tr>
<tr class="separator:a5f93b97f665d79e5896411aab6eefe59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f7c5b4c054412850c0728c87411850"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a89f7c5b4c054412850c0728c87411850"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a89f7c5b4c054412850c0728c87411850">operator*</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; &amp;&amp;m)</td></tr>
<tr class="separator:a89f7c5b4c054412850c0728c87411850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8aec50cdb37b41e7660ce47eb94668"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8f8aec50cdb37b41e7660ce47eb94668"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a8f8aec50cdb37b41e7660ce47eb94668">fromMaybe</a> (T &amp;def, <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a8f8aec50cdb37b41e7660ce47eb94668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maybeから値を取り出す関数．もしNothingなら引数のデフォルト値を返す．a -&gt; Maybe a -&gt; a.  <a href="#a8f8aec50cdb37b41e7660ce47eb94668">More...</a><br /></td></tr>
<tr class="separator:a8f8aec50cdb37b41e7660ce47eb94668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55d131e28fddf951e625266728da64f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af55d131e28fddf951e625266728da64f"><td class="memTemplItemLeft" align="right" valign="top">T const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#af55d131e28fddf951e625266728da64f">fromMaybe</a> (T const &amp;def, <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; const &amp;m)</td></tr>
<tr class="separator:af55d131e28fddf951e625266728da64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad06d86e8c02e2e92915836f5f9bcc2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abad06d86e8c02e2e92915836f5f9bcc2"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#abad06d86e8c02e2e92915836f5f9bcc2">fromMaybe</a> (T &amp;&amp;def, <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; &amp;&amp;m)</td></tr>
<tr class="separator:abad06d86e8c02e2e92915836f5f9bcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d86afec32c12c4b25c6954bb062321"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a50d86afec32c12c4b25c6954bb062321"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a50d86afec32c12c4b25c6954bb062321">fromMaybe</a> (T &amp;&amp;def, boost::none_t m)</td></tr>
<tr class="separator:a50d86afec32c12c4b25c6954bb062321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab453d7332268dc96edbd8db46bf249"><td class="memTemplParams" colspan="2">template&lt;class F , class C &gt; </td></tr>
<tr class="memitem:a7ab453d7332268dc96edbd8db46bf249"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a7ab453d7332268dc96edbd8db46bf249">mapMaybe</a> (F const &amp;f, C const &amp;list) -&gt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::template rebind&lt; typename std::remove_reference&lt; decltype(*(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(f, std::declval&lt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::value_type &gt;())))&gt;::type &gt;</td></tr>
<tr class="memdesc:a7ab453d7332268dc96edbd8db46bf249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maybeを返す関数を指定するfilter関数．(a -&gt; Maybe b) -&gt; [a] -&gt; [b].  <a href="#a7ab453d7332268dc96edbd8db46bf249">More...</a><br /></td></tr>
<tr class="separator:a7ab453d7332268dc96edbd8db46bf249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb90d9f305dbf9d6f7baf790daa54265"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:acb90d9f305dbf9d6f7baf790daa54265"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#acb90d9f305dbf9d6f7baf790daa54265">operator&gt;&gt;=</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; const &amp;m, F const &amp;f) -&gt; decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(f, std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:acb90d9f305dbf9d6f7baf790daa54265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Haskell風のbind演算子. Maybe m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b.  <a href="#acb90d9f305dbf9d6f7baf790daa54265">More...</a><br /></td></tr>
<tr class="separator:acb90d9f305dbf9d6f7baf790daa54265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feb67d99478836770118144be4cb417"><td class="memTemplParams" colspan="2">template&lt;class F , class T &gt; </td></tr>
<tr class="memitem:a1feb67d99478836770118144be4cb417"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a1feb67d99478836770118144be4cb417">operator&lt;&lt;=</a> (F const &amp;f, <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T &gt; const &amp;m) -&gt; decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(f, std::declval&lt; T &gt;()))</td></tr>
<tr class="memdesc:a1feb67d99478836770118144be4cb417"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++に合わせたbind演算子. Maybe m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b.  <a href="#a1feb67d99478836770118144be4cb417">More...</a><br /></td></tr>
<tr class="separator:a1feb67d99478836770118144be4cb417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aeb657956b0dfafff73410b9c85450"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a03aeb657956b0dfafff73410b9c85450"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a03aeb657956b0dfafff73410b9c85450">operator&lt;&lt;=</a> (<a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T1 &gt; &amp;m, T2 const &amp;v) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; T1 &gt; &amp;</td></tr>
<tr class="memdesc:a03aeb657956b0dfafff73410b9c85450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maybeオブジェクトへの再代入を行う演算子  <a href="#a03aeb657956b0dfafff73410b9c85450">More...</a><br /></td></tr>
<tr class="separator:a03aeb657956b0dfafff73410b9c85450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d67d01d1803dcb72538da634e29544"><td class="memTemplParams" colspan="2">template&lt;class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class T  = typename impl::container_traits&lt;CR&gt;::value_type&gt; </td></tr>
<tr class="memitem:a23d67d01d1803dcb72538da634e29544"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a23d67d01d1803dcb72538da634e29544">remove_duplicates</a> (C &amp;container)</td></tr>
<tr class="memdesc:a23d67d01d1803dcb72538da634e29544"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナの要素から重複した値を削除  <a href="#a23d67d01d1803dcb72538da634e29544">More...</a><br /></td></tr>
<tr class="separator:a23d67d01d1803dcb72538da634e29544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8075c448a2814e18b1116fab36bc03"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:afc8075c448a2814e18b1116fab36bc03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#afc8075c448a2814e18b1116fab36bc03">remove_one</a> (C &amp;container, typename boost::call_traits&lt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::value_type &gt;::param_type remove)</td></tr>
<tr class="memdesc:afc8075c448a2814e18b1116fab36bc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナから指定した値を1つ削除  <a href="#afc8075c448a2814e18b1116fab36bc03">More...</a><br /></td></tr>
<tr class="separator:afc8075c448a2814e18b1116fab36bc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd1f54d7d2cae9f0311c31853bec4ae"><td class="memTemplParams" colspan="2">template&lt;class Pred , class C &gt; </td></tr>
<tr class="memitem:abfd1f54d7d2cae9f0311c31853bec4ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#abfd1f54d7d2cae9f0311c31853bec4ae">remove_one_if</a> (C &amp;container, Pred remove_pred)</td></tr>
<tr class="memdesc:abfd1f54d7d2cae9f0311c31853bec4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナから述語条件を満たす値を1つ削除  <a href="#abfd1f54d7d2cae9f0311c31853bec4ae">More...</a><br /></td></tr>
<tr class="separator:abfd1f54d7d2cae9f0311c31853bec4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133944aec31d6c9e4dec7ff05e2deffb"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a133944aec31d6c9e4dec7ff05e2deffb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a133944aec31d6c9e4dec7ff05e2deffb">remove_all</a> (C &amp;container, typename boost::call_traits&lt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::value_type &gt;::param_type remove)</td></tr>
<tr class="memdesc:a133944aec31d6c9e4dec7ff05e2deffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナから指定した値を全削除  <a href="#a133944aec31d6c9e4dec7ff05e2deffb">More...</a><br /></td></tr>
<tr class="separator:a133944aec31d6c9e4dec7ff05e2deffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0de7db91a4969b0187b8b4c2380bd23"><td class="memTemplParams" colspan="2">template&lt;class Pred , class C &gt; </td></tr>
<tr class="memitem:ae0de7db91a4969b0187b8b4c2380bd23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae0de7db91a4969b0187b8b4c2380bd23">remove_all_if</a> (C &amp;container, Pred remove_pred)</td></tr>
<tr class="memdesc:ae0de7db91a4969b0187b8b4c2380bd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナから述語条件を満たす値を全削除  <a href="#ae0de7db91a4969b0187b8b4c2380bd23">More...</a><br /></td></tr>
<tr class="separator:ae0de7db91a4969b0187b8b4c2380bd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7d35d5a05e2464005b5b4ddea0b3ff"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:aaf7d35d5a05e2464005b5b4ddea0b3ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aaf7d35d5a05e2464005b5b4ddea0b3ff">shuffle</a> (C &amp;container)</td></tr>
<tr class="memdesc:aaf7d35d5a05e2464005b5b4ddea0b3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナの要素をシャッフル  <a href="#aaf7d35d5a05e2464005b5b4ddea0b3ff">More...</a><br /></td></tr>
<tr class="separator:aaf7d35d5a05e2464005b5b4ddea0b3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cba63dbbb129004b5f73a99c83141d"><td class="memTemplParams" colspan="2">template&lt;class... Cs&gt; </td></tr>
<tr class="memitem:a92cba63dbbb129004b5f73a99c83141d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a92cba63dbbb129004b5f73a99c83141d">shuffle</a> (Cs &amp;...containers)</td></tr>
<tr class="memdesc:a92cba63dbbb129004b5f73a99c83141d"><td class="mdescLeft">&#160;</td><td class="mdescRight">複数のコンテナの同じインデックスの要素を対応させながらシャッフル  <a href="#a92cba63dbbb129004b5f73a99c83141d">More...</a><br /></td></tr>
<tr class="separator:a92cba63dbbb129004b5f73a99c83141d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4930f26b351db7ea4dcb510d9c53119f"><td class="memTemplParams" colspan="2">template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class T  = typename impl::sequence_container_traits&lt;CR&gt;::value_type, typename std::enable_if&lt; impl::has_random_access_iter&lt; CR &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a4930f26b351db7ea4dcb510d9c53119f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a4930f26b351db7ea4dcb510d9c53119f">sort</a> (C &amp;container, F &amp;&amp;binary_op) -&gt; decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(std::forward&lt; F &gt;(binary_op), std::declval&lt; T &gt;(), std::declval&lt; T &gt;()), void())</td></tr>
<tr class="memdesc:a4930f26b351db7ea4dcb510d9c53119f"><td class="mdescLeft">&#160;</td><td class="mdescRight">標準ソート関数のラッパ  <a href="#a4930f26b351db7ea4dcb510d9c53119f">More...</a><br /></td></tr>
<tr class="separator:a4930f26b351db7ea4dcb510d9c53119f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad870d6cd92e89746ca63158651629eb"><td class="memTemplParams" colspan="2">template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class T  = typename impl::static_container_traits&lt;CR&gt;::value_type, class D  = void, typename std::enable_if&lt; impl::has_random_access_iter&lt; CR &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:aad870d6cd92e89746ca63158651629eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aad870d6cd92e89746ca63158651629eb">sort</a> (C &amp;container, F &amp;&amp;binary_op) -&gt; decltype(<a class="el" href="namespacesig_1_1impl.html#aa4016c716f13711dc08188fbf2376999">impl::eval</a>(std::forward&lt; F &gt;(binary_op), std::declval&lt; T &gt;(), std::declval&lt; T &gt;()), void())</td></tr>
<tr class="separator:aad870d6cd92e89746ca63158651629eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae507cd57b9d1969c8a5f2dcae8e7b3c2"><td class="memTemplParams" colspan="2">template&lt;class C , class F , class T  = typename impl::container_traits&lt;typename impl::remove_const_reference&lt;C&gt;::type&gt;::value_type&gt; </td></tr>
<tr class="memitem:ae507cd57b9d1969c8a5f2dcae8e7b3c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae507cd57b9d1969c8a5f2dcae8e7b3c2">sort_with_index</a> (C &amp;&amp;container, F &amp;&amp;binary_op)</td></tr>
<tr class="memdesc:ae507cd57b9d1969c8a5f2dcae8e7b3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ソート前の位置を保持してソート  <a href="#ae507cd57b9d1969c8a5f2dcae8e7b3c2">More...</a><br /></td></tr>
<tr class="separator:ae507cd57b9d1969c8a5f2dcae8e7b3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad51d4efad46a8864eccad700cf61f5e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aad51d4efad46a8864eccad700cf61f5e">wstr_to_str</a> (std::wstring const &amp;src) -&gt; std::string</td></tr>
<tr class="memdesc:aad51d4efad46a8864eccad700cf61f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ワイド文字 -&gt; マルチバイト文字  <a href="#aad51d4efad46a8864eccad700cf61f5e">More...</a><br /></td></tr>
<tr class="separator:aad51d4efad46a8864eccad700cf61f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0946147a9e10e3efaee507d93b406e"><td class="memTemplParams" colspan="2">template&lt;class C , class R  = typename impl::container_traits&lt;C&gt;::template rebind&lt;std::string&gt;, typename std::enable_if&lt; std::is_same&lt; typename impl::container_traits&lt; C &gt;::value_type, std::wstring &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a4d0946147a9e10e3efaee507d93b406e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a4d0946147a9e10e3efaee507d93b406e">wstr_to_str</a> (C const &amp;src) -&gt; R</td></tr>
<tr class="memdesc:a4d0946147a9e10e3efaee507d93b406e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ワイド文字 -&gt; マルチバイト文字  <a href="#a4d0946147a9e10e3efaee507d93b406e">More...</a><br /></td></tr>
<tr class="separator:a4d0946147a9e10e3efaee507d93b406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e21be275ac0fa7858875b1832d50b4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac1e21be275ac0fa7858875b1832d50b4">str_to_wstr</a> (std::string const &amp;src) -&gt; std::wstring</td></tr>
<tr class="memdesc:ac1e21be275ac0fa7858875b1832d50b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">マルチバイト文字 -&gt; ワイド文字  <a href="#ac1e21be275ac0fa7858875b1832d50b4">More...</a><br /></td></tr>
<tr class="separator:ac1e21be275ac0fa7858875b1832d50b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d27eb84b02748727c2c57f8c797fc2"><td class="memTemplParams" colspan="2">template&lt;class C , class R  = typename impl::container_traits&lt;C&gt;::template rebind&lt;std::wstring&gt;, typename std::enable_if&lt; std::is_same&lt; typename impl::container_traits&lt; C &gt;::value_type, std::string &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a35d27eb84b02748727c2c57f8c797fc2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a35d27eb84b02748727c2c57f8c797fc2">str_to_wstr</a> (C const &amp;src) -&gt; R</td></tr>
<tr class="memdesc:a35d27eb84b02748727c2c57f8c797fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">マルチバイト文字 -&gt; ワイド文字  <a href="#a35d27eb84b02748727c2c57f8c797fc2">More...</a><br /></td></tr>
<tr class="separator:a35d27eb84b02748727c2c57f8c797fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b93ba472519ee0c0262921703c0ad"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aa74b93ba472519ee0c0262921703c0ad">utf8_to_utf16</a> (std::string const &amp;src) -&gt; std::u16string</td></tr>
<tr class="memdesc:aa74b93ba472519ee0c0262921703c0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 -&gt; UTF-16.  <a href="#aa74b93ba472519ee0c0262921703c0ad">More...</a><br /></td></tr>
<tr class="separator:aa74b93ba472519ee0c0262921703c0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b8e0198e9cc03be44a2c3cf3e94b37"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a53b8e0198e9cc03be44a2c3cf3e94b37">utf16_to_utf8</a> (std::u16string const &amp;src) -&gt; std::string</td></tr>
<tr class="memdesc:a53b8e0198e9cc03be44a2c3cf3e94b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-16 -&gt; UTF-8.  <a href="#a53b8e0198e9cc03be44a2c3cf3e94b37">More...</a><br /></td></tr>
<tr class="separator:a53b8e0198e9cc03be44a2c3cf3e94b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e703b31c3c41197fd05b1403064e2a1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a8e703b31c3c41197fd05b1403064e2a1">utf8_to_utf32</a> (std::string const &amp;src) -&gt; std::u32string</td></tr>
<tr class="memdesc:a8e703b31c3c41197fd05b1403064e2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 -&gt; UTF-32.  <a href="#a8e703b31c3c41197fd05b1403064e2a1">More...</a><br /></td></tr>
<tr class="separator:a8e703b31c3c41197fd05b1403064e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef55bd51e3af96c30503cc4ca51a12"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae4ef55bd51e3af96c30503cc4ca51a12">utf32_to_utf8</a> (std::u32string const &amp;src) -&gt; std::string</td></tr>
<tr class="memdesc:ae4ef55bd51e3af96c30503cc4ca51a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-32 -&gt; UTF-8.  <a href="#ae4ef55bd51e3af96c30503cc4ca51a12">More...</a><br /></td></tr>
<tr class="separator:ae4ef55bd51e3af96c30503cc4ca51a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc44bda76acdb1ae1ee8a72252ae2fee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#afc44bda76acdb1ae1ee8a72252ae2fee">sjis_to_utf16</a> (std::string const &amp;src) -&gt; std::u16string</td></tr>
<tr class="memdesc:afc44bda76acdb1ae1ee8a72252ae2fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShiftJIS -&gt; UTF-16.  <a href="#afc44bda76acdb1ae1ee8a72252ae2fee">More...</a><br /></td></tr>
<tr class="separator:afc44bda76acdb1ae1ee8a72252ae2fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7738904e0c2e47d2f7c9c4ad2627615"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aa7738904e0c2e47d2f7c9c4ad2627615">utf16_to_sjis</a> (std::u16string const &amp;src) -&gt; std::string</td></tr>
<tr class="memdesc:aa7738904e0c2e47d2f7c9c4ad2627615"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-16 -&gt; ShiftJIS.  <a href="#aa7738904e0c2e47d2f7c9c4ad2627615">More...</a><br /></td></tr>
<tr class="separator:aa7738904e0c2e47d2f7c9c4ad2627615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32eefbdbf2955fb1e971be030d1d499"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aa32eefbdbf2955fb1e971be030d1d499">sjis_to_utf8</a> (std::string const &amp;src) -&gt; std::string</td></tr>
<tr class="memdesc:aa32eefbdbf2955fb1e971be030d1d499"><td class="mdescLeft">&#160;</td><td class="mdescRight">ShiftJIS -&gt; UTF-8.  <a href="#aa32eefbdbf2955fb1e971be030d1d499">More...</a><br /></td></tr>
<tr class="separator:aa32eefbdbf2955fb1e971be030d1d499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03810f5be4d2bd5c311f2f4096a2076a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a03810f5be4d2bd5c311f2f4096a2076a">utf8_to_sjis</a> (std::string const &amp;src) -&gt; std::string</td></tr>
<tr class="memdesc:a03810f5be4d2bd5c311f2f4096a2076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 -&gt; ShiftJIS.  <a href="#a03810f5be4d2bd5c311f2f4096a2076a">More...</a><br /></td></tr>
<tr class="separator:a03810f5be4d2bd5c311f2f4096a2076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c8c4feeb72922c1e9075d8e26a1bc5"><td class="memTemplParams" colspan="2">template&lt;template&lt; class T_, class=std::allocator&lt; T_ &gt;&gt; class CSeq = std::vector, class S  = std::string, class TS  = impl::string_t&lt;S&gt;&gt; </td></tr>
<tr class="memitem:ac4c8c4feeb72922c1e9075d8e26a1bc5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac4c8c4feeb72922c1e9075d8e26a1bc5">split</a> (S const &amp;src, <a class="el" href="namespacesig_1_1impl.html#a3ea003bbd2deb3b72d07dee313153ab6">impl::string_t</a>&lt; S &gt; const &amp;delimiter) -&gt; CSeq&lt; TS &gt;</td></tr>
<tr class="memdesc:ac4c8c4feeb72922c1e9075d8e26a1bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">文字列(src)をある文字列(delimiter)を目印に分割する  <a href="#ac4c8c4feeb72922c1e9075d8e26a1bc5">More...</a><br /></td></tr>
<tr class="separator:ac4c8c4feeb72922c1e9075d8e26a1bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01c7c755c15f366a01d1043544eec44"><td class="memTemplParams" colspan="2">template&lt;template&lt; class T_, class=std::allocator&lt; T_ &gt;&gt; class CSeq = std::vector&gt; </td></tr>
<tr class="memitem:ae01c7c755c15f366a01d1043544eec44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae01c7c755c15f366a01d1043544eec44">split</a> (char const *const src, char const *const delimiter) -&gt; CSeq&lt; std::string &gt;</td></tr>
<tr class="separator:ae01c7c755c15f366a01d1043544eec44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf74ac7f74851ac3e9555169a3e3025d"><td class="memTemplParams" colspan="2">template&lt;template&lt; class T_, class=std::allocator&lt; T_ &gt;&gt; class CSeq = std::vector&gt; </td></tr>
<tr class="memitem:abf74ac7f74851ac3e9555169a3e3025d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#abf74ac7f74851ac3e9555169a3e3025d">split</a> (wchar_t const *const src, wchar_t const *const delimiter) -&gt; CSeq&lt; std::wstring &gt;</td></tr>
<tr class="separator:abf74ac7f74851ac3e9555169a3e3025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4068ed2b3401745a42dadf4cc7281be8"><td class="memTemplParams" colspan="2">template&lt;class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class S  = typename impl::SStreamSelector&lt;typename impl::container_traits&lt;CR&gt;::value_type&gt;::string&gt; </td></tr>
<tr class="memitem:a4068ed2b3401745a42dadf4cc7281be8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a4068ed2b3401745a42dadf4cc7281be8">cat</a> (C &amp;&amp;container, typename <a class="el" href="structsig_1_1impl_1_1identity.html">sig::impl::identity</a>&lt; S &gt;::type const &amp;delimiter, std::locale osstream_locale=std::locale(&quot;&quot;)) -&gt; S</td></tr>
<tr class="memdesc:a4068ed2b3401745a42dadf4cc7281be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">コンテナ中の各文字列や数値を結合  <a href="#a4068ed2b3401745a42dadf4cc7281be8">More...</a><br /></td></tr>
<tr class="separator:a4068ed2b3401745a42dadf4cc7281be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad808e6bfaa18b3ef22460e96dc776225"><td class="memTemplParams" colspan="2">template&lt;class T , class S  = typename impl::SStreamSelector&lt;T&gt;::string&gt; </td></tr>
<tr class="memitem:ad808e6bfaa18b3ef22460e96dc776225"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ad808e6bfaa18b3ef22460e96dc776225">cat</a> (std::initializer_list&lt; T &gt; container, typename <a class="el" href="structsig_1_1impl_1_1identity.html">sig::impl::identity</a>&lt; S &gt;::type const &amp;delimiter, std::locale osstream_locale=std::locale(&quot;&quot;)) -&gt; S</td></tr>
<tr class="separator:ad808e6bfaa18b3ef22460e96dc776225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542a9b9d1534f2e2c78bed52a94f75f5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a542a9b9d1534f2e2c78bed52a94f75f5">escape_regex</a> (std::string const &amp;expression) -&gt; std::string</td></tr>
<tr class="memdesc:a542a9b9d1534f2e2c78bed52a94f75f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">与えられた文字中に含まれる、正規表現の特殊文字をエスケープする  <a href="#a542a9b9d1534f2e2c78bed52a94f75f5">More...</a><br /></td></tr>
<tr class="separator:a542a9b9d1534f2e2c78bed52a94f75f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656827307e7e2ede5b24862a0236c3d7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a656827307e7e2ede5b24862a0236c3d7">escape_regex</a> (std::wstring const &amp;expression) -&gt; std::wstring</td></tr>
<tr class="separator:a656827307e7e2ede5b24862a0236c3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98f3fec5daa1616ea0157146a0eb1ac"><td class="memTemplParams" colspan="2">template&lt;class S &gt; </td></tr>
<tr class="memitem:ab98f3fec5daa1616ea0157146a0eb1ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab98f3fec5daa1616ea0157146a0eb1ac">make_regex</a> (S const &amp;expression) -&gt; typename <a class="el" href="structsig_1_1impl_1_1_str2_regex_selector.html">impl::Str2RegexSelector</a>&lt; <a class="el" href="namespacesig_1_1impl.html#a3ea003bbd2deb3b72d07dee313153ab6">impl::string_t</a>&lt; S &gt;&gt;::regex</td></tr>
<tr class="memdesc:ab98f3fec5daa1616ea0157146a0eb1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">エスケープ処理を行い、regexオブジェクトを返す  <a href="#ab98f3fec5daa1616ea0157146a0eb1ac">More...</a><br /></td></tr>
<tr class="separator:ab98f3fec5daa1616ea0157146a0eb1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0b08a65c2bfa9e0c3bc1bc274fb8d6"><td class="memTemplParams" colspan="2">template&lt;class S , class TS  = impl::string_t&lt;S&gt;&gt; </td></tr>
<tr class="memitem:a8c0b08a65c2bfa9e0c3bc1bc274fb8d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a8c0b08a65c2bfa9e0c3bc1bc274fb8d6">regex_search</a> (S &amp;&amp;src, typename <a class="el" href="structsig_1_1impl_1_1_str2_regex_selector.html">impl::Str2RegexSelector</a>&lt; TS &gt;::regex const &amp;expression) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; std::vector&lt; std::vector&lt; TS &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a8c0b08a65c2bfa9e0c3bc1bc274fb8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::regex_search のラッパ関数  <a href="#a8c0b08a65c2bfa9e0c3bc1bc274fb8d6">More...</a><br /></td></tr>
<tr class="separator:a8c0b08a65c2bfa9e0c3bc1bc274fb8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c5193ef23c23aa269a6b2bc6ed3b5b"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; container_traits&lt; C &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:af3c5193ef23c23aa269a6b2bc6ed3b5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#af3c5193ef23c23aa269a6b2bc6ed3b5b">save_line</a> (C const &amp;src, typename <a class="el" href="structsig_1_1impl_1_1_f_stream_selector.html">impl::FStreamSelector</a>&lt; typename container_traits&lt; C &gt;::value_type &gt;::ofstream &amp;ofs)</td></tr>
<tr class="separator:af3c5193ef23c23aa269a6b2bc6ed3b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8076b49b677a978f418b45fc41c9e35"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; container_traits&lt; C &gt;::exist &amp;&amp;!container_traits&lt; typename container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:ac8076b49b677a978f418b45fc41c9e35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac8076b49b677a978f418b45fc41c9e35">save_num</a> (C const &amp;src, FilepassString const &amp;file_pass, <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">WriteMode</a> mode=<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>, std::string delimiter=&quot;\n&quot;)</td></tr>
<tr class="separator:ac8076b49b677a978f418b45fc41c9e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19874ad616ce905822fd376bdcbfb0f3"><td class="memTemplParams" colspan="2">template&lt;class CC , typename std::enable_if&lt; container_traits&lt; typename container_traits&lt; CC &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a19874ad616ce905822fd376bdcbfb0f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a19874ad616ce905822fd376bdcbfb0f3">save_num</a> (CC const &amp;src, FilepassString const &amp;file_pass, <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">WriteMode</a> mode=<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>, std::string delimiter1=&quot;\n&quot;, std::string delimiter2=&quot;\n\n&quot;)</td></tr>
<tr class="separator:a19874ad616ce905822fd376bdcbfb0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b235dfeb8f4187bcc578d564589a4e"><td class="memTemplParams" colspan="2">template&lt;class C , class R  = typename container_traits&lt;C&gt;::value_type&gt; </td></tr>
<tr class="memitem:a17b235dfeb8f4187bcc578d564589a4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a17b235dfeb8f4187bcc578d564589a4e">read_line</a> (C &amp;empty_dest, <a class="el" href="namespacesig.html#ac5389e85e2d81c2cdb3262b870130b53">IfsSelector</a>&lt; R &gt; &amp;ifs, std::function&lt; R(typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt; R, std::string, std::string, std::wstring &gt;::type) &gt; const &amp;conv=nullptr)</td></tr>
<tr class="separator:a17b235dfeb8f4187bcc578d564589a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c1019a172cbc0e8a6902c47179d035"><td class="memTemplParams" colspan="2">template&lt;class C , class R  = typename container_traits&lt;C&gt;::value_type&gt; </td></tr>
<tr class="memitem:a51c1019a172cbc0e8a6902c47179d035"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a51c1019a172cbc0e8a6902c47179d035">read_line</a> (C &amp;empty_dest, FilepassString const &amp;file_pass, std::function&lt; R(typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt; R, std::string, std::string, std::wstring &gt;::type)&gt; const &amp;conv=nullptr)</td></tr>
<tr class="separator:a51c1019a172cbc0e8a6902c47179d035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccaf18321471597128caf5188d63f4e"><td class="memTemplParams" colspan="2">template&lt;class R , class C  = std::vector&lt;R&gt;&gt; </td></tr>
<tr class="memitem:a6ccaf18321471597128caf5188d63f4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a6ccaf18321471597128caf5188d63f4e">read_line</a> (<a class="el" href="namespacesig.html#ac5389e85e2d81c2cdb3262b870130b53">IfsSelector</a>&lt; R &gt; &amp;ifs) -&gt; <a class="el" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">Just</a>&lt; C &gt;</td></tr>
<tr class="separator:a6ccaf18321471597128caf5188d63f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52d0046b9f7ac9ed91db7cc091747da"><td class="memTemplParams" colspan="2">template&lt;class R , class C  = std::vector&lt;R&gt;&gt; </td></tr>
<tr class="memitem:ab52d0046b9f7ac9ed91db7cc091747da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab52d0046b9f7ac9ed91db7cc091747da">read_line</a> (FilepassString const &amp;file_pass) -&gt; <a class="el" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">Just</a>&lt; C &gt;</td></tr>
<tr class="separator:ab52d0046b9f7ac9ed91db7cc091747da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c60185cca68cde6203af4da6669b13b"><td class="memTemplParams" colspan="2">template&lt;class R , class C  = std::vector&lt;R&gt;&gt; </td></tr>
<tr class="memitem:a5c60185cca68cde6203af4da6669b13b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a5c60185cca68cde6203af4da6669b13b">read_line</a> (FilepassStringC file_pass) -&gt; <a class="el" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">Just</a>&lt; C &gt;</td></tr>
<tr class="separator:a5c60185cca68cde6203af4da6669b13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006af42a5e66092c6e8709b3fedb78e3"><td class="memTemplParams" colspan="2">template&lt;class C , class RT  = typename container_traits&lt;C&gt;::value_type, typename std::enable_if&lt;!container_traits&lt; typename container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a006af42a5e66092c6e8709b3fedb78e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a006af42a5e66092c6e8709b3fedb78e3">read_num</a> (C &amp;empty_dest, FilepassString const &amp;file_pass, std::string delimiter=&quot;\n&quot;)</td></tr>
<tr class="separator:a006af42a5e66092c6e8709b3fedb78e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0037b2d7146782a93186d41cd55540b3"><td class="memTemplParams" colspan="2">template&lt;class CC , class RC  = typename container_traits&lt;CC&gt;::value_type, class RT  = typename container_traits&lt;RC&gt;::value_type&gt; </td></tr>
<tr class="memitem:a0037b2d7146782a93186d41cd55540b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0037b2d7146782a93186d41cd55540b3">read_num</a> (CC &amp;empty_dest, FilepassString const &amp;file_pass, std::string delimiter1=&quot;\n&quot;, std::string delimiter2=&quot;\n\n&quot;)</td></tr>
<tr class="separator:a0037b2d7146782a93186d41cd55540b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03538ac6018ae7a9bf0e6e8ce26fe65"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; container_traits&lt; C &gt;::exist &amp;&amp;!container_traits&lt; typename container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:aa03538ac6018ae7a9bf0e6e8ce26fe65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aa03538ac6018ae7a9bf0e6e8ce26fe65">read_num</a> (FilepassString const &amp;file_pass, std::string delimiter=&quot;\n&quot;) -&gt; Just&lt; C &gt;</td></tr>
<tr class="separator:aa03538ac6018ae7a9bf0e6e8ce26fe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf29df3a5a8ad232497a9c0d41f2415"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aecf29df3a5a8ad232497a9c0d41f2415">Print</a> (std::string const &amp;text, char const *const delimiter=&quot;\n&quot;)</td></tr>
<tr class="separator:aecf29df3a5a8ad232497a9c0d41f2415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f0a25eb1e9135493cc96693ae477f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a95f0a25eb1e9135493cc96693ae477f0">Print</a> (std::wstring const &amp;text, wchar_t const *const delimiter=L&quot;\n&quot;)</td></tr>
<tr class="separator:a95f0a25eb1e9135493cc96693ae477f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a75c8e07a98a11fe5b6b8daa9d0c436"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class...&gt; class Container, typename std::enable_if&lt;!std::is_same&lt; T, std::wstring &gt;::value &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a3a75c8e07a98a11fe5b6b8daa9d0c436"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a3a75c8e07a98a11fe5b6b8daa9d0c436">Print</a> (Container&lt; T &gt; const &amp;container, char const *const delimiter=&quot;\n&quot;)</td></tr>
<tr class="separator:a3a75c8e07a98a11fe5b6b8daa9d0c436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664dfc3971cbf05de6eed3afcf0b7394"><td class="memTemplParams" colspan="2">template&lt;template&lt; class...&gt; class Container&gt; </td></tr>
<tr class="memitem:a664dfc3971cbf05de6eed3afcf0b7394"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a664dfc3971cbf05de6eed3afcf0b7394">Print</a> (Container&lt; std::wstring &gt; const &amp;container, wchar_t const *const delimiter=L&quot;\n&quot;)</td></tr>
<tr class="separator:a664dfc3971cbf05de6eed3afcf0b7394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9641221a9d6b8501706996e9dd0af6"><td class="memTemplParams" colspan="2">template&lt;class CC1 , class CC2 &gt; </td></tr>
<tr class="memitem:add9641221a9d6b8501706996e9dd0af6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#add9641221a9d6b8501706996e9dd0af6">GaleShapley</a> (CC1 const &amp;men_vec, CC2 const &amp;women_vec)</td></tr>
<tr class="separator:add9641221a9d6b8501706996e9dd0af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e4efd41fbaef9d3c2b4f0a285edfb"><td class="memTemplParams" colspan="2">template&lt;class C  = std::vector&lt;int&gt;&gt; </td></tr>
<tr class="memitem:a133e4efd41fbaef9d3c2b4f0a285edfb"><td class="memTemplItemLeft" align="right" valign="top">C&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a133e4efd41fbaef9d3c2b4f0a285edfb">make_unique_numbers</a> (uint n, int <a class="el" href="namespacesig.html#a45c7cfeba4eb923ac22a289dccbef2a1">min</a>, int <a class="el" href="namespacesig.html#aab27dcfc67c86de4742fb2879c566805">max</a>, bool debug)</td></tr>
<tr class="memdesc:a133e4efd41fbaef9d3c2b4f0a285edfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">重複の無い一様分布の整数乱数を生成  <a href="#a133e4efd41fbaef9d3c2b4f0a285edfb">More...</a><br /></td></tr>
<tr class="separator:a133e4efd41fbaef9d3c2b4f0a285edfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aece976557907baf76250e2da7c136660"><td class="memTemplParams" colspan="2">template&lt;class IFS_CHAR , class C , class R  = typename impl::container_traits&lt;C&gt;::value_type&gt; </td></tr>
<tr class="memitem:aece976557907baf76250e2da7c136660"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aece976557907baf76250e2da7c136660">load_line</a> (C &amp;empty_dest, std::basic_ifstream&lt; IFS_CHAR &gt; &amp;ifs)</td></tr>
<tr class="memdesc:aece976557907baf76250e2da7c136660"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルから1行ずつ読み込む（ifstreamを指定）  <a href="#aece976557907baf76250e2da7c136660">More...</a><br /></td></tr>
<tr class="separator:aece976557907baf76250e2da7c136660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea20e0cd765952c183f90073eb3428bc"><td class="memTemplParams" colspan="2">template&lt;class C , class R  = typename impl::container_traits&lt;C&gt;::value_type&gt; </td></tr>
<tr class="memitem:aea20e0cd765952c183f90073eb3428bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aea20e0cd765952c183f90073eb3428bc">load_line</a> (C &amp;empty_dest, FilepassString const &amp;file_pass)</td></tr>
<tr class="memdesc:aea20e0cd765952c183f90073eb3428bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルから1行ずつ読み込む（ファイル名を指定）  <a href="#aea20e0cd765952c183f90073eb3428bc">More...</a><br /></td></tr>
<tr class="separator:aea20e0cd765952c183f90073eb3428bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0e78169e5be4b7762ecab3937a0274d3"><td class="memTemplParams" colspan="2">template&lt;class ISTR  = std::string, class C  = std::vector&lt;ISTR&gt;&gt; </td></tr>
<tr class="memitem:a0e78169e5be4b7762ecab3937a0274d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0e78169e5be4b7762ecab3937a0274d3">load_line</a> (FilepassString const &amp;file_pass) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; C &gt;</td></tr>
<tr class="memdesc:a0e78169e5be4b7762ecab3937a0274d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルから1行ずつ読み込み、結果を返す（ファイル名を指定）  <a href="#a0e78169e5be4b7762ecab3937a0274d3">More...</a><br /></td></tr>
<tr class="separator:a0e78169e5be4b7762ecab3937a0274d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b493c09afd9a058d5a7863aa036c147"><td class="memTemplParams" colspan="2">template&lt;class ISTR  = std::string, class R  = ISTR, class C  = std::vector&lt;R&gt;&gt; </td></tr>
<tr class="memitem:a7b493c09afd9a058d5a7863aa036c147"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a7b493c09afd9a058d5a7863aa036c147">load_line</a> (FilepassStringC file_pass) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; C &gt;</td></tr>
<tr class="separator:a7b493c09afd9a058d5a7863aa036c147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5db0c96ded610e9b029bdf192de1dcb5"><td class="memTemplParams" colspan="2">template&lt;class IFS_CHAR , class F , class C , class R  = typename impl::container_traits&lt;C&gt;::value_type&gt; </td></tr>
<tr class="memitem:a5db0c96ded610e9b029bdf192de1dcb5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a5db0c96ded610e9b029bdf192de1dcb5">load_line</a> (C &amp;empty_dest, std::basic_ifstream&lt; IFS_CHAR &gt; &amp;ifs, F const &amp;conv)</td></tr>
<tr class="memdesc:a5db0c96ded610e9b029bdf192de1dcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルから1行ずつ読み込み、同時に変換処理を行う（ifstreamを指定）  <a href="#a5db0c96ded610e9b029bdf192de1dcb5">More...</a><br /></td></tr>
<tr class="separator:a5db0c96ded610e9b029bdf192de1dcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffb973fb3d164d1ec5c65b22ffecc47"><td class="memTemplParams" colspan="2">template&lt;class ISTR  = std::string, class F , class C , class R  = typename impl::container_traits&lt;C&gt;::value_type&gt; </td></tr>
<tr class="memitem:a8ffb973fb3d164d1ec5c65b22ffecc47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a8ffb973fb3d164d1ec5c65b22ffecc47">load_line</a> (C &amp;empty_dest, FilepassString const &amp;file_pass, F const &amp;conv)</td></tr>
<tr class="memdesc:a8ffb973fb3d164d1ec5c65b22ffecc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルから1行ずつ読み込み、同時に変換処理を行う（ファイル名を指定）  <a href="#a8ffb973fb3d164d1ec5c65b22ffecc47">More...</a><br /></td></tr>
<tr class="separator:a8ffb973fb3d164d1ec5c65b22ffecc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a07036bf2289ae139bb6cc04d7d9067bc"><td class="memTemplParams" colspan="2">template&lt;class C , class RT  = typename impl::container_traits&lt;C&gt;::value_type, typename std::enable_if&lt;!impl::container_traits&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a07036bf2289ae139bb6cc04d7d9067bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a07036bf2289ae139bb6cc04d7d9067bc">load_num</a> (C &amp;empty_dest, FilepassString const &amp;file_pass, std::string delimiter=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a07036bf2289ae139bb6cc04d7d9067bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">数値列を読み込む  <a href="#a07036bf2289ae139bb6cc04d7d9067bc">More...</a><br /></td></tr>
<tr class="separator:a07036bf2289ae139bb6cc04d7d9067bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df3d6dbc99465ff05675f4481d19946"><td class="memTemplParams" colspan="2">template&lt;class R , class C  = std::vector&lt;R&gt;, typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &amp;&amp;!impl::container_traits&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a6df3d6dbc99465ff05675f4481d19946"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a6df3d6dbc99465ff05675f4481d19946">load_num</a> (FilepassString const &amp;file_pass, std::string delimiter=&quot;\n&quot;) -&gt; Maybe&lt; C &gt;</td></tr>
<tr class="memdesc:a6df3d6dbc99465ff05675f4481d19946"><td class="mdescLeft">&#160;</td><td class="mdescRight">数値列を読み込み、結果を返す  <a href="#a6df3d6dbc99465ff05675f4481d19946">More...</a><br /></td></tr>
<tr class="separator:a6df3d6dbc99465ff05675f4481d19946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa795e9f5abad527ab43c501ad705b3b0"><td class="memTemplParams" colspan="2">template&lt;class CC , class RC  = typename impl::container_traits&lt;CC&gt;::value_type, class RT  = typename impl::container_traits&lt;RC&gt;::value_type&gt; </td></tr>
<tr class="memitem:aa795e9f5abad527ab43c501ad705b3b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#aa795e9f5abad527ab43c501ad705b3b0">load_num2d</a> (CC &amp;empty_dest, FilepassString const &amp;file_pass, std::string delimiter)</td></tr>
<tr class="memdesc:aa795e9f5abad527ab43c501ad705b3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元配列の数値(ex:行列)を読み込む  <a href="#aa795e9f5abad527ab43c501ad705b3b0">More...</a><br /></td></tr>
<tr class="separator:aa795e9f5abad527ab43c501ad705b3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc87b5d90a8c04ce75e6d8e9636a7db"><td class="memTemplParams" colspan="2">template&lt;class R , class CC  = std::vector&lt;std::vector&lt;R&gt;&gt;, typename std::enable_if&lt; impl::container_traits&lt; typename impl::container_traits&lt; CC &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:adbc87b5d90a8c04ce75e6d8e9636a7db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#adbc87b5d90a8c04ce75e6d8e9636a7db">load_num2d</a> (FilepassString const &amp;file_pass, std::string delimiter) -&gt; <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt; CC &gt;</td></tr>
<tr class="memdesc:adbc87b5d90a8c04ce75e6d8e9636a7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元配列の数値(ex:行列)を読み込む  <a href="#adbc87b5d90a8c04ce75e6d8e9636a7db">More...</a><br /></td></tr>
<tr class="separator:adbc87b5d90a8c04ce75e6d8e9636a7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab132bd55c25dd0e0ed148431369d89a8"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;!impl::container_traits&lt; T &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:ab132bd55c25dd0e0ed148431369d89a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ab132bd55c25dd0e0ed148431369d89a8">save_line</a> (T src, typename <a class="el" href="structsig_1_1impl_1_1_f_stream_selector.html">impl::FStreamSelector</a>&lt; T &gt;::ofstream &amp;ofs)</td></tr>
<tr class="memdesc:ab132bd55c25dd0e0ed148431369d89a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルへ1行ずつ保存  <a href="#ab132bd55c25dd0e0ed148431369d89a8">More...</a><br /></td></tr>
<tr class="separator:ab132bd55c25dd0e0ed148431369d89a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058e1b02b74bc59032bef4eadbf57834"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a058e1b02b74bc59032bef4eadbf57834"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a058e1b02b74bc59032bef4eadbf57834">save_line</a> (C const &amp;src, typename <a class="el" href="structsig_1_1impl_1_1_f_stream_selector.html">impl::FStreamSelector</a>&lt; typename <a class="el" href="structsig_1_1impl_1_1container__traits.html">impl::container_traits</a>&lt; C &gt;::value_type &gt;::ofstream &amp;ofs)</td></tr>
<tr class="memdesc:a058e1b02b74bc59032bef4eadbf57834"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルへ1行ずつまとめて保存  <a href="#a058e1b02b74bc59032bef4eadbf57834">More...</a><br /></td></tr>
<tr class="separator:a058e1b02b74bc59032bef4eadbf57834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3f10cfa5afdf6dab57ba4f1c775f0f"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt;!impl::container_traits&lt; T &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:a5e3f10cfa5afdf6dab57ba4f1c775f0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#a5e3f10cfa5afdf6dab57ba4f1c775f0f">save_line</a> (T src, FilepassString const &amp;file_pass, <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">WriteMode</a> open_mode=<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>)</td></tr>
<tr class="memdesc:a5e3f10cfa5afdf6dab57ba4f1c775f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルへ1行ずつ保存  <a href="#a5e3f10cfa5afdf6dab57ba4f1c775f0f">More...</a><br /></td></tr>
<tr class="separator:a5e3f10cfa5afdf6dab57ba4f1c775f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad613769c1571433e408ba0b8773cc6a8"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:ad613769c1571433e408ba0b8773cc6a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#ad613769c1571433e408ba0b8773cc6a8">save_line</a> (C const &amp;src, FilepassString const &amp;file_pass, <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">WriteMode</a> open_mode=<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>)</td></tr>
<tr class="memdesc:ad613769c1571433e408ba0b8773cc6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ファイルへ1行ずつまとめて保存  <a href="#ad613769c1571433e408ba0b8773cc6a8">More...</a><br /></td></tr>
<tr class="separator:ad613769c1571433e408ba0b8773cc6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:addc3f0929bab231f9df1da232c03f250"><td class="memTemplParams" colspan="2">template&lt;class C , typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &amp;&amp;!impl::container_traits&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:addc3f0929bab231f9df1da232c03f250"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#addc3f0929bab231f9df1da232c03f250">save_num</a> (C const &amp;src, FilepassString const &amp;file_pass, std::string delimiter, <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">WriteMode</a> open_mode=<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>)</td></tr>
<tr class="memdesc:addc3f0929bab231f9df1da232c03f250"><td class="mdescLeft">&#160;</td><td class="mdescRight">数値列(ex:ベクトル)の保存  <a href="#addc3f0929bab231f9df1da232c03f250">More...</a><br /></td></tr>
<tr class="separator:addc3f0929bab231f9df1da232c03f250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6126d24e606964ae51527f7c4a68b49"><td class="memTemplParams" colspan="2">template&lt;class CC , typename std::enable_if&lt; impl::container_traits&lt; typename impl::container_traits&lt; CC &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </td></tr>
<tr class="memitem:af6126d24e606964ae51527f7c4a68b49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesig.html#af6126d24e606964ae51527f7c4a68b49">save_num</a> (CC const &amp;src, FilepassString const &amp;file_pass, std::string delimiter, <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">WriteMode</a> open_mode=<a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>)</td></tr>
<tr class="memdesc:af6126d24e606964ae51527f7c4a68b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">2次元配列の数値(ex:行列)を保存  <a href="#af6126d24e606964ae51527f7c4a68b49">More...</a><br /></td></tr>
<tr class="separator:af6126d24e606964ae51527f7c4a68b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac4b505b4274b92cf40d4707249ce9856"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_binary_distance.html">BinaryDistance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac4b505b4274b92cf40d4707249ce9856">binary_distance</a></td></tr>
<tr class="memdesc:ac4b505b4274b92cf40d4707249ce9856"><td class="mdescLeft">&#160;</td><td class="mdescRight">バイナリ距離を求める関数（関数オブジェクト）  <a href="#ac4b505b4274b92cf40d4707249ce9856">More...</a><br /></td></tr>
<tr class="separator:ac4b505b4274b92cf40d4707249ce9856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66ca30e3e48b1c84ad5581c96e26281"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_canberra_distance.html">CanberraDistance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac66ca30e3e48b1c84ad5581c96e26281">canberra_distance</a></td></tr>
<tr class="memdesc:ac66ca30e3e48b1c84ad5581c96e26281"><td class="mdescLeft">&#160;</td><td class="mdescRight">キャンベラ距離を求める関数（関数オブジェクト）  <a href="#ac66ca30e3e48b1c84ad5581c96e26281">More...</a><br /></td></tr>
<tr class="separator:ac66ca30e3e48b1c84ad5581c96e26281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0207655f912a6cacfffbfaf34b56f5d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_cosine_similarity.html">CosineSimilarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a0207655f912a6cacfffbfaf34b56f5d4">cosine_similarity</a></td></tr>
<tr class="memdesc:a0207655f912a6cacfffbfaf34b56f5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">コサイン類似度を求める関数（関数オブジェクト）  <a href="#a0207655f912a6cacfffbfaf34b56f5d4">More...</a><br /></td></tr>
<tr class="separator:a0207655f912a6cacfffbfaf34b56f5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae91b25f01097a1034007df173aee16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_j_s___divergence.html">JS_Divergence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#abae91b25f01097a1034007df173aee16">js_divergence</a></td></tr>
<tr class="memdesc:abae91b25f01097a1034007df173aee16"><td class="mdescLeft">&#160;</td><td class="mdescRight">JS情報量を求める関数（関数オブジェクト）  <a href="#abae91b25f01097a1034007df173aee16">More...</a><br /></td></tr>
<tr class="separator:abae91b25f01097a1034007df173aee16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262388a714d056b15831fe341665101c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_k_l___divergence.html">KL_Divergence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a262388a714d056b15831fe341665101c">kl_divergence</a></td></tr>
<tr class="memdesc:a262388a714d056b15831fe341665101c"><td class="mdescLeft">&#160;</td><td class="mdescRight">KL情報量を求める関数（関数オブジェクト）  <a href="#a262388a714d056b15831fe341665101c">More...</a><br /></td></tr>
<tr class="separator:a262388a714d056b15831fe341665101c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe87854e097c01e5262eebd1fd7ed18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesig.html#a2021fa0b889efd4766c666fa312e52c3">ManhattanDistance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#acbe87854e097c01e5262eebd1fd7ed18">manhattan_distance</a></td></tr>
<tr class="memdesc:acbe87854e097c01e5262eebd1fd7ed18"><td class="mdescLeft">&#160;</td><td class="mdescRight">マンハッタン距離を求める関数（関数オブジェクト）  <a href="#acbe87854e097c01e5262eebd1fd7ed18">More...</a><br /></td></tr>
<tr class="separator:acbe87854e097c01e5262eebd1fd7ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c397bd9fe42a9d25e65d8de0444486"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesig.html#a86e7da4764bbcbf7c70a300d401c431f">EuclideanDistance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a02c397bd9fe42a9d25e65d8de0444486">euclidean_distance</a></td></tr>
<tr class="memdesc:a02c397bd9fe42a9d25e65d8de0444486"><td class="mdescLeft">&#160;</td><td class="mdescRight">ユークリッド距離を求める関数（関数オブジェクト）  <a href="#a02c397bd9fe42a9d25e65d8de0444486">More...</a><br /></td></tr>
<tr class="separator:a02c397bd9fe42a9d25e65d8de0444486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee341a411722c0b228c2df3dc604c15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_norm.html">Norm</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aeee341a411722c0b228c2df3dc604c15">norm_L1</a></td></tr>
<tr class="memdesc:aeee341a411722c0b228c2df3dc604c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1ノルムを求める関数（関数オブジェクト）  <a href="#aeee341a411722c0b228c2df3dc604c15">More...</a><br /></td></tr>
<tr class="separator:aeee341a411722c0b228c2df3dc604c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f5307120c0bb6a2dab899dbf675729"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_norm.html">Norm</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#ae7f5307120c0bb6a2dab899dbf675729">norm_L2</a></td></tr>
<tr class="memdesc:ae7f5307120c0bb6a2dab899dbf675729"><td class="mdescLeft">&#160;</td><td class="mdescRight">L2ノルムを求める関数（関数オブジェクト）  <a href="#ae7f5307120c0bb6a2dab899dbf675729">More...</a><br /></td></tr>
<tr class="separator:ae7f5307120c0bb6a2dab899dbf675729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f37903b93d965c46af91cfeddaa889"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_max_norm.html">MaxNorm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#ac4f37903b93d965c46af91cfeddaa889">norm_max</a></td></tr>
<tr class="memdesc:ac4f37903b93d965c46af91cfeddaa889"><td class="mdescLeft">&#160;</td><td class="mdescRight">最大ノルムを求める関数（関数オブジェクト）  <a href="#ac4f37903b93d965c46af91cfeddaa889">More...</a><br /></td></tr>
<tr class="separator:ac4f37903b93d965c46af91cfeddaa889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711206fafbfbbb458fbdeee6cb025915"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a711206fafbfbbb458fbdeee6cb025915">enabler</a></td></tr>
<tr class="separator:a711206fafbfbbb458fbdeee6cb025915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee91ea8ce00d3e85c52089138770fbff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_absolute_error.html">AbsoluteError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#aee91ea8ce00d3e85c52089138770fbff">absolute_error</a></td></tr>
<tr class="separator:aee91ea8ce00d3e85c52089138770fbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4905260658f296637729209011e8f2dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structsig_1_1_relative_error.html">RelativeError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesig.html#a4905260658f296637729209011e8f2dd">relative_error</a></td></tr>
<tr class="separator:a4905260658f296637729209011e8f2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a86e7da4764bbcbf7c70a300d401c431f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesig.html#a86e7da4764bbcbf7c70a300d401c431f">sig::EuclideanDistance</a> = typedef <a class="el" href="structsig_1_1_minkowski_distance.html">MinkowskiDistance</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="minkowski__distance_8hpp_source.html#l00065">65</a> of file <a class="el" href="minkowski__distance_8hpp_source.html">minkowski_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5389e85e2d81c2cdb3262b870130b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesig.html#ac5389e85e2d81c2cdb3262b870130b53">sig::IfsSelector</a> = typedef typename <a class="el" href="structsig_1_1impl_1_1_same_if.html">impl::SameIf</a>&lt;R, std::string, std::ifstream, std::wifstream&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00295">295</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2021fa0b889efd4766c666fa312e52c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesig.html#a2021fa0b889efd4766c666fa312e52c3">sig::ManhattanDistance</a> = typedef <a class="el" href="structsig_1_1_minkowski_distance.html">MinkowskiDistance</a>&lt;1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="minkowski__distance_8hpp_source.html#l00045">45</a> of file <a class="el" href="minkowski__distance_8hpp_source.html">minkowski_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a87fb6486ef20975e88be5c8758e5a8cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesig.html#a87fb6486ef20975e88be5c8758e5a8cc">sig::matrix_u</a> = typedef boost::numeric::ublas::matrix&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00028">28</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7ec5a8e01f01010a96578cdc817cd26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">sig::Maybe</a> = typedef boost::optional&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00045">45</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a778d6619d275a84c0214370668335ba3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesig.html#a778d6619d275a84c0214370668335ba3">sig::vector_u</a> = typedef boost::numeric::ublas::vector&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00049">49</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a6076be9dec1b137e4e5b6651689f654c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">sig::WriteMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SaveLine, SaveNum の保存に関する設定 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b"></a>overwrite&#160;</td><td class="fielddoc">
<p>上書き </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d"></a>append&#160;</td><td class="fielddoc">
<p>末尾追記 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b"></a>overwrite&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d"></a>append&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="save_8hpp_source.html#l00024">24</a> of file <a class="el" href="save_8hpp_source.html">save.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6076be9dec1b137e4e5b6651689f654c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654c">sig::WriteMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b"></a>overwrite&#160;</td><td class="fielddoc">
<p>上書き </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d"></a>append&#160;</td><td class="fielddoc">
<p>末尾追記 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b"></a>overwrite&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d"></a>append&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00174">174</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab0eb27ca84afdbec45509d56c9a555f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sig::abs_delta </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00235">235</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af31b064bc840051da0ef1c67fed91662"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::abs_delta </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(v1 &lt; v2 ? v2 - v1 : v1 - v2)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2変数の差の絶対値を返す </p>
<dl class="section pre"><dt>Precondition</dt><dd>operator&lt; , operator-</dd></dl>
<div class="fragment"><div class="line">static_assert( <a class="code" href="namespacesig.html#ab0eb27ca84afdbec45509d56c9a555f4">abs_delta</a>(1, 3) == 2, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert( <a class="code" href="namespacesig.html#ab0eb27ca84afdbec45509d56c9a555f4">abs_delta</a>(-2, -1) == 1, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert( <a class="code" href="namespacesig.html#ab0eb27ca84afdbec45509d56c9a555f4">abs_delta</a>(3.0, 1.5) == 1.5, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert( <a class="code" href="namespacesig.html#ab0eb27ca84afdbec45509d56c9a555f4">abs_delta</a>(3, 1.5) == 1.5, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00255">255</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5ebd0df3cc83f534a217a21267e388a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::And </td>
          <td>(</td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00024">24</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af97a9bf9ace305f1a6f67db5b9e3ff35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B1 , class... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::And </td>
          <td>(</td>
          <td class="paramtype">B1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>conds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>可変長 and </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond,conds</td><td>bool変数 または operator boolが定義されたオブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>全引数に対してandを取った結果</dd></dl>
<div class="fragment"><div class="line">static_assert(<a class="code" href="namespacesig.html#ae5ebd0df3cc83f534a217a21267e388a">And</a>(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!<a class="code" href="namespacesig.html#ae5ebd0df3cc83f534a217a21267e388a">And</a>(<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00043">43</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac08872f62c0e8a5c033c8e4276c793ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double sig::average </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>平均 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>平均を求めたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec{1,2,3,4};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> ave = <a class="code" href="namespacesig.html#ac08872f62c0e8a5c033c8e4276c793ef">average</a>(vec);  <span class="comment">// 2.5</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00223">223</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef46d46fcfa19cf6f982cfa76b59cb13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OP , class T1 , class T2 , typename std::enable_if&lt; (!impl::container_traits&lt; typename impl::remove_const_reference&lt; T1 &gt;::type &gt;::exist)&amp;&amp;(!impl::container_traits&lt; typename impl::remove_const_reference&lt; T2 &gt;::type &gt;::exist) &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::binary_operation </td>
          <td>(</td>
          <td class="paramtype">OP &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::remove_const_reference&lt; decltype(impl::eval(std::forward&lt;OP&gt;(func), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二項演算 (scalar and scalar) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>二項演算関数 </td></tr>
    <tr><td class="paramname">v1</td><td>引数1 </td></tr>
    <tr><td class="paramname">v2</td><td>引数2</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>演算結果 </dd></dl>

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00033">33</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe70dfe9bde4e26219c60532199b6220"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OP , class C1 , class C2 , class CR1  = typename impl::remove_const_reference&lt;C1&gt;::type, class CR2  = typename impl::remove_const_reference&lt;C2&gt;::type, class AT1  = typename impl::forward_element&lt;C1&gt;::type, class AT2  = typename impl::forward_element&lt;C2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; CR1 &gt;::exist &amp;&amp;impl::container_traits&lt; CR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::binary_operation </td>
          <td>(</td>
          <td class="paramtype">OP &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::container_traits&lt;CR1&gt;::template rebind&lt;
		typename impl::remove_const_reference&lt;decltype(impl::eval(
			std::forward&lt;OP&gt;(func),
			std::declval&lt;AT1&gt;(),
			std::declval&lt;AT2&gt;()
		))&gt;::type
	&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二項演算 (element-wise: container and container) </p>

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00049">49</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93a576cc7805287c7d80c00d80a4862c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OP , class C , class T , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class ET  = typename impl::forward_element&lt;C&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; CR &gt;::exist &amp;&amp;(!impl::container_traits&lt; typename impl::remove_const_reference&lt; T &gt;::type &gt;::exist) &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::binary_operation </td>
          <td>(</td>
          <td class="paramtype">OP &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::container_traits&lt;CR&gt;::template rebind&lt;
		typename impl::remove_const_reference&lt;decltype(impl::eval(
			std::forward&lt;OP&gt;(func),
			std::declval&lt;ET&gt;(),
			v
		))&gt;::type
	&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二項演算 (element-wise: container and scalar) </p>

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00076">76</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afded19a25b0601f23afc985153b0c047"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OP , class T , class C , class ET  = typename impl::forward_element&lt;C&gt;::type, class CR  = typename impl::remove_const_reference&lt;C&gt;::type, typename std::enable_if&lt; (!impl::container_traits&lt; typename impl::remove_const_reference&lt; T &gt;::type &gt;::exist)&amp;&amp;impl::container_traits&lt; CR &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::binary_operation </td>
          <td>(</td>
          <td class="paramtype">OP &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::container_traits&lt;CR&gt;::template rebind&lt;
		typename impl::remove_const_reference&lt;decltype(impl::eval(
			std::forward&lt;OP&gt;(func),
			v,
			std::declval&lt;ET&gt;()
		))&gt;::type
	&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二項演算 (element-wise: scalar and container) </p>

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00104">104</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4068ed2b3401745a42dadf4cc7281be8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class S  = typename impl::SStreamSelector&lt;typename impl::container_traits&lt;CR&gt;::value_type&gt;::string&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::cat </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structsig_1_1impl_1_1identity.html">sig::impl::identity</a>&lt; S &gt;::type const &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::locale&#160;</td>
          <td class="paramname"><em>osstream_locale</em> = <code>std::locale(&quot;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; S
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナ中の各文字列や数値を結合 </p>
<p>conatiner中の要素が数値の場合、ostringstreamで出力される文字列に変換される</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>文字列か数値が格納されたコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">delimiter</td><td>結合する文字列間に挿入される文字列 </td></tr>
    <tr><td class="paramname">osstream_locale</td><td>[option] 出力に影響するロケール</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結合した文字列</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> cat1 = <a class="code" href="namespacesig.html#a4068ed2b3401745a42dadf4cc7281be8">cat</a>(std::vector&lt;std::string&gt;{<span class="stringliteral">&quot;eins&quot;</span>, <span class="stringliteral">&quot;zwei&quot;</span>, <span class="stringliteral">&quot;drei&quot;</span>}, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> cat2 = <a class="code" href="namespacesig.html#a4068ed2b3401745a42dadf4cc7281be8">cat</a>(std::list&lt;std::wstring&gt;{L<span class="stringliteral">&quot;eins&quot;</span>, L<span class="stringliteral">&quot;zwei&quot;</span>, L<span class="stringliteral">&quot;drei&quot;</span>}, L<span class="stringliteral">&quot;,&quot;</span>);</div>
<div class="line"></div>
<div class="line">assert(cat1 == <span class="stringliteral">&quot;einszweidrei&quot;</span>);</div>
<div class="line">assert(cat2 == L<span class="stringliteral">&quot;eins,zwei,drei&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="manipulate_8hpp_source.html#l00155">155</a> of file <a class="el" href="manipulate_8hpp_source.html">manipulate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad808e6bfaa18b3ef22460e96dc776225"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S  = typename impl::SStreamSelector&lt;T&gt;::string&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::cat </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structsig_1_1impl_1_1identity.html">sig::impl::identity</a>&lt; S &gt;::type const &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::locale&#160;</td>
          <td class="paramname"><em>osstream_locale</em> = <code>std::locale(&quot;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; S
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>containerがinitializer_listの場合</p>
<dl class="section see"><dt>See also</dt><dd>cat(C const&amp; container, S const&amp; delimiter, std::locale osstream_locale) </dd></dl>

<p>Definition at line <a class="el" href="manipulate_8hpp_source.html#l00177">177</a> of file <a class="el" href="manipulate_8hpp_source.html">manipulate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a959750718a766b4dfde00851301c4df3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sig::check_range </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値の範囲チェック </p>
<p>min ≦ val ≦ max であるか確認</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>確認したい値 </td></tr>
    <tr><td class="paramname">min</td><td>範囲の下限 </td></tr>
    <tr><td class="paramname">max</td><td>範囲の上限</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>valが範囲内に収まっているか</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> cr = 5;</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a959750718a766b4dfde00851301c4df3">check_range</a>(cr, 0, 10));</div>
<div class="line">assert(!<a class="code" href="namespacesig.html#a959750718a766b4dfde00851301c4df3">check_range</a>(cr, 0, 3));</div>
<div class="line">assert(cr == 5);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00347">347</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a645b1356484f8299988517c57d7fcb0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sig::clear_file </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ファイル内容の初期化 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_pass</td><td>初期化したいファイルのパス</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./src&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#a645b1356484f8299988517c57d7fcb0d">clear_file</a>(fpass);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="save_8hpp_source.html#l00043">43</a> of file <a class="el" href="save_8hpp_source.html">save.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abeda63170c841fbe2a5af92d094ff11b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C1 , class C2 , typename std::enable_if&lt; impl::container_traits&lt; C1 &gt;::exist &amp;&amp;impl::container_traits&lt; C2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::compound_assignment </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>assign_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C1 &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 const &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナへの代入演算 (element-wise: container and container) </p>
<p>indexが対応するsrcとdestの各要素に関数を適用し、その結果をdestコンテナに格納する</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assign_op</td><td>srcとdestの各要素を引数に取る関数 </td></tr>
    <tr><td class="paramname">dest</td><td>代入先のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">src</td><td>任意のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 4&gt; data0{ 1, 2, 3, 4 };        <span class="comment">// sig::array</span></div>
<div class="line">std::list&lt;double&gt; data1{ 1.1, -3.3, 5.5 };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#abeda63170c841fbe2a5af92d094ff11b">compound_assignment</a>([](<span class="keywordtype">double</span>&amp; v1, <span class="keywordtype">int</span> v2){ v1 -= v2; }, data1, data0);</div>
<div class="line"></div>
<div class="line">data1;      <span class="comment">// { 0.1, -5.3, 2.5 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="assign__operation_8hpp_source.html#l00039">39</a> of file <a class="el" href="assign__operation_8hpp_source.html">assign_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc3e02fa708a67feecc8f85033565f60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C , class T , typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &amp;&amp;!impl::container_traits&lt; T &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::compound_assignment </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>assign_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナへの代入演算 (element-wise: container and scalar) </p>
<p>srcとdestの各要素に関数を適用し、その結果をdestコンテナに格納する</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assign_op</td><td>srcの各要素を処理する関数 </td></tr>
    <tr><td class="paramname">dest</td><td>代入先のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">src</td><td>任意の値</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; data{ <span class="stringliteral">&quot;ein&quot;</span>, <span class="stringliteral">&quot;zwei&quot;</span>, <span class="stringliteral">&quot;drei&quot;</span> };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#abeda63170c841fbe2a5af92d094ff11b">compound_assignment</a>([](std::string&amp; str, std::string add){ str += add; }, data, std::string(<span class="stringliteral">&quot;-hander&quot;</span>));</div>
<div class="line"></div>
<div class="line">data;       <span class="comment">// { &quot;ein-hander&quot;, &quot;zwei-hander&quot;, &quot;drei-hander&quot; }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="assign__operation_8hpp_source.html#l00066">66</a> of file <a class="el" href="assign__operation_8hpp_source.html">assign_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebb3dcdb16ea8594712d59f1d088a9db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B1 , class B2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::Consistency </td>
          <td>(</td>
          <td class="paramtype">B1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AとBの真偽一致でtrueを返す (⇔ !xor) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond,conds</td><td>bool変数 または operator boolが定義されたオブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>!xorの結果</dd></dl>
<div class="fragment"><div class="line">static_assert(<a class="code" href="namespacesig.html#aebb3dcdb16ea8594712d59f1d088a9db">Consistency</a>(<span class="keyword">true</span>, <span class="keyword">true</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!<a class="code" href="namespacesig.html#aebb3dcdb16ea8594712d59f1d088a9db">Consistency</a>(<span class="keyword">true</span>, <span class="keyword">false</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!<a class="code" href="namespacesig.html#aebb3dcdb16ea8594712d59f1d088a9db">Consistency</a>(<span class="keyword">false</span>, <span class="keyword">true</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="namespacesig.html#aebb3dcdb16ea8594712d59f1d088a9db">Consistency</a>(<span class="keyword">false</span>, <span class="keyword">false</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00113">113</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cb3d39faa9c144155f7d78c4a33ddbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RC , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::copy </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; RC
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>別の種類のコンテナに要素をコピーする </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RC</td><td>コピー先のコンテナ型（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>コピー元のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>コピーされたコンテナ </dd></dl>

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00269">269</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae4ee53c674e3a308bb58e327eea48a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::div </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(binary_operation(div_t(), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00151">151</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b3170f013606fc56af11041f81580aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F1 , class F2 , class T , class... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::dotProduct </td>
          <td>(</td>
          <td class="paramtype">F1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>fold_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>oper_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>lists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>可変長個のコンテナに対して関数適用して結果を集約する関数 </p>
<p>(a -&gt; a -&gt; a) -&gt; (b -&gt; c -&gt; ... -&gt; a) -&gt; a0 -&gt; [b] -&gt; [c] -&gt; ... -&gt; a <br />
a0はaに暗黙的に型変換可能 <br />
listsのいずれかの末尾に到達するまで集約の計算が行われる</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fold_func</td><td>oper_funcで計算した結果を集約する関数 (a -&gt; a -&gt; a) </td></tr>
    <tr><td class="paramname">oper_func</td><td>各コンテナの要素を引数に取る関数 (b -&gt; c -&gt; ... -&gt; a) </td></tr>
    <tr><td class="paramname">init</td><td>初期値 a0 </td></tr>
    <tr><td class="paramname">lists...</td><td>データが格納されたコンテナ [b] [c] ...（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果 a</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 5&gt; data1{ 1, 2, 3, 4, 5 };     <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; data2{ 1, -3, 5, 2, 10 };</div>
<div class="line"><span class="keyword">const</span> std::list&lt;int&gt; data3{ 1, -3, 5, 2 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> dp = <a class="code" href="namespacesig.html#a0b3170f013606fc56af11041f81580aa">dotProduct</a>(</div>
<div class="line">    [](<span class="keywordtype">double</span> <a class="code" href="namespacesig.html#a8f13a59ba58f7ba6759826a62cff3abc">sum</a>, <span class="keywordtype">double</span> a){ <span class="keywordflow">return</span> sum + a; },</div>
<div class="line">    [](<span class="keywordtype">int</span> b, <span class="keywordtype">int</span> c, <span class="keywordtype">int</span> d, <span class="keywordtype">double</span> e){ <span class="keywordflow">return</span> std::pow(b*b + c*c + d*d + e*e, 0.25); },</div>
<div class="line">    0,</div>
<div class="line">    data1, data2, data3, array&lt;double, 4&gt;{ 1.1, 2.2, 3.3, 4.4 }</div>
<div class="line">);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="fold_8hpp_source.html#l00111">111</a> of file <a class="el" href="fold_8hpp_source.html">fold.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a10b5b129dc12b56daaaf61461e2917d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::drop </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; CR
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナの先頭からn個を削除したコンテナを返す </p>
<p>uint -&gt; [a] -&gt; [a]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>先頭から順に削除する要素の個数 </td></tr>
    <tr><td class="paramname">list</td><td>ソースとなるコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナ（listと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 4&gt; data1{ 1, 2, 3, 4 };        <span class="comment">// sig::array</span></div>
<div class="line">std::vector&lt;int&gt; data2{ 1, -3, 5, 2, 10 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> t1 = <a class="code" href="namespacesig.html#a10b5b129dc12b56daaaf61461e2917d8">drop</a>(2, data1);       <span class="comment">// array&lt;int, 4&gt;{ 3, 4 }</span></div>
<div class="line"><span class="keyword">auto</span> t2 = <a class="code" href="namespacesig.html#a10b5b129dc12b56daaaf61461e2917d8">drop</a>(3, data2);       <span class="comment">// std::vector&lt;int&gt; data2{ 2, 10 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="list__deal_8hpp_source.html#l00256">256</a> of file <a class="el" href="list__deal_8hpp_source.html">list_deal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f3f9d9c09ab0c38afaeafcdd66adb27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , typename std::enable_if&lt;!(impl::is_string&lt; T1 &gt;::value||impl::is_string&lt; T2 &gt;::value)&gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::equal </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>数値の簡易等値比較（厳密な計算でない場合の使用を想定） </p>
<p>浮動小数点型の誤差をある程度許容． デフォルトでは 10^(-12) 未満の誤差を無視</p>
<div class="fragment"><div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(1, 1));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(1, 1u));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(1u, 1));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(1u, 1u));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(1, 1.0));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(1.0, 1));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;a&#39;</span>));</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> ct = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">double</span> f = 0.0; !<a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(f, 1); f += 0.01, ++ct){</div>
<div class="line">    <span class="keywordflow">if</span> (ct &gt;= 100) assert(<span class="keyword">false</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00282">282</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4e8ce81f827b4b3ac6147aafc4a7d410"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S1 , class S2 , typename std::enable_if&lt;(impl::is_string&lt; S1 &gt;::value &amp;&amp;impl::is_string&lt; S2 &gt;::value)&gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::equal </td>
          <td>(</td>
          <td class="paramtype">S1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字列の等値比較 </p>
<div class="fragment"><div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(<span class="stringliteral">&quot;tes&quot;</span>, <span class="stringliteral">&quot;tes&quot;</span>));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(L<span class="stringliteral">&quot;tes&quot;</span>, L<span class="stringliteral">&quot;tes&quot;</span>));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(<span class="stringliteral">&quot;tes&quot;</span>, std::string(<span class="stringliteral">&quot;tes&quot;</span>)));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(std::string(<span class="stringliteral">&quot;tes&quot;</span>), <span class="stringliteral">&quot;tes&quot;</span>));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(L<span class="stringliteral">&quot;tes&quot;</span>, std::wstring(L<span class="stringliteral">&quot;tes&quot;</span>)));</div>
<div class="line">assert( <a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(std::wstring(L<span class="stringliteral">&quot;tes&quot;</span>), L<span class="stringliteral">&quot;tes&quot;</span>));</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00305">305</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd502a09c7dcf0affc2be0850b821a28"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::equal_tolerant </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::common_type&lt; T1, T2 &gt;::type&#160;</td>
          <td class="paramname"><em>margin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>指定範囲内の誤差を許した等値比較 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1,v2</td><td>等値比較したい値 </td></tr>
    <tr><td class="paramname">margin</td><td>許容する誤差</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>誤差を許容した等値比較の結果</dd></dl>
<div class="fragment"><div class="line">assert( <a class="code" href="namespacesig.html#afd502a09c7dcf0affc2be0850b821a28">equal_tolerant</a>(0.001, 0.002, 0.001));</div>
<div class="line">assert(!<a class="code" href="namespacesig.html#afd502a09c7dcf0affc2be0850b821a28">equal_tolerant</a>(0.001, 0.003, 0.001));</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00324">324</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1071fa1cfcfea2462228c6d77d819a9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::erase </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename impl::sequence_container_traits&lt; C &gt;::value_type const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00213">213</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b0ca470394d270e10e30e5f5479a7b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::erase </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename impl::associative_container_traits&lt; C &gt;::value_type const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00219">219</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3223517453f819a6838eeab4cc797da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::erase </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename impl::hash_container_traits&lt; C &gt;::value_type const &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00225">225</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2baf963f8dca01b87498bc2b4026eac0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class F , typename std::enable_if&lt; impl::sequence_container_traits&lt; C &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::erase_if </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>remove_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00232">232</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a542a9b9d1534f2e2c78bed52a94f75f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::escape_regex </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td> -&gt; std::string
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>与えられた文字中に含まれる、正規表現の特殊文字をエスケープする </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> raw1 = <span class="stringliteral">&quot;? or () must be escaped&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> escaped1 = <a class="code" href="namespacesig.html#a542a9b9d1534f2e2c78bed52a94f75f5">escape_regex</a>(raw1);</div>
<div class="line"><span class="keyword">auto</span> escaped2 = <a class="code" href="namespacesig.html#a542a9b9d1534f2e2c78bed52a94f75f5">escape_regex</a>(L<span class="stringliteral">&quot;?とか()はエスケープすべき文字&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> test1 = R<span class="stringliteral">&quot;(\? or \(\) must be escaped)&quot;;</span></div>
<div class="line"><span class="stringliteral">assert(escaped1 == test1);</span></div>
<div class="line"><span class="stringliteral"></span><span class="keyword">auto</span> test2 = LR<span class="stringliteral">&quot;(\?とか\(\)はエスケープすべき文字)&quot;;</span></div>
<div class="line"><span class="stringliteral">assert(escaped2 == test2);</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="regex_8hpp_source.html#l00088">88</a> of file <a class="el" href="regex_8hpp_source.html">regex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a656827307e7e2ede5b24862a0236c3d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::escape_regex </td>
          <td>(</td>
          <td class="paramtype">std::wstring const &amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td> -&gt; std::wstring
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#a542a9b9d1534f2e2c78bed52a94f75f5" title="与えられた文字中に含まれる、正規表現の特殊文字をエスケープする ">escape_regex(std::string const&amp; expression)</a> </dd></dl>

<p>Definition at line <a class="el" href="regex_8hpp_source.html#l00098">98</a> of file <a class="el" href="regex_8hpp_source.html">regex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2cb33b8d1e2904d1507be34b4fc9eb3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class ET  = typename impl::forward_element&lt;C&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::filter </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナから指定条件を満たす要素を抽出する </p>
<p>(a -&gt; Bool) -&gt; [a] -&gt; [a]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>条件判定を行う述語関数 (a -&gt; Bool) </td></tr>
    <tr><td class="paramname">list</td><td>データが格納されたコンテナ [a]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果のコンテナ [a]（コンテナはlistと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::unordered_set&lt;double&gt; data2{ 0, 1.1, -2.2, 3.3 };</div>
<div class="line">array&lt;std::string, 3&gt; data2{ <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bbb&quot;</span>, <span class="stringliteral">&quot;cc&quot;</span> };    <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> fl1 = <a class="code" href="namespacesig.html#a2cb33b8d1e2904d1507be34b4fc9eb3c">filter</a>([](<span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> v % 2; }, data1);</div>
<div class="line"><span class="keyword">auto</span> fl2 = <a class="code" href="namespacesig.html#a2cb33b8d1e2904d1507be34b4fc9eb3c">filter</a>([](std::string <span class="keyword">const</span>&amp; v){ <span class="keywordflow">return</span> v.length() &lt; 3; }, std::move(data2));</div>
<div class="line"></div>
<div class="line">fl1;    <span class="comment">// std::unordered_set&lt;double&gt;{ -2.2 }</span></div>
<div class="line">fl2;    <span class="comment">// array&lt;std::string, 3&gt;{ &quot;a&quot;, &quot;cc&quot; } // array[2]は未使用</span></div>
<div class="line"></div>
<div class="line">assert(data2[0].empty() &amp;&amp; data2[2].empty() &amp;&amp; (!data2[1].empty()) );</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="filter_8hpp_source.html#l00044">44</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d443d245a0a734cddc895d8b79a4fd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class ET  = typename impl::forward_element&lt;C&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::filter </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナから指定条件を満たす要素を抽出する(反復回数を表すindexが利用できる) </p>
<p>(int -&gt; a -&gt; Bool) -&gt; int -&gt; [a] -&gt; [a]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>条件判定を行う述語関数 (int -&gt; a -&gt; Bool) </td></tr>
    <tr><td class="paramname">init</td><td>indexの初期値 int </td></tr>
    <tr><td class="paramname">list</td><td>データが格納されたコンテナ [a]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果のコンテナ [a]（コンテナはlistと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;double, 3&gt; data{ 1.1, 1.5, 4 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> filt3 = <a class="code" href="namespacesig.html#a2cb33b8d1e2904d1507be34b4fc9eb3c">filter</a>([](<span class="keywordtype">int</span> i, <span class="keywordtype">double</span> v){ <span class="keywordflow">return</span> v / i &lt; 1; }, 1, data);</div>
<div class="line">data;       <span class="comment">// { 1.5 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="filter_8hpp_source.html#l00075">75</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae66e7d0f082892a119563d6433ebdd91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::foldl </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナの先頭からたたみ込み </p>
<p>(a -&gt; b -&gt; a) -&gt; a0 -&gt; [b] -&gt; a <br />
a0はaに暗黙的に型変換可能</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>関数 (a -&gt; b -&gt; a) </td></tr>
    <tr><td class="paramname">init</td><td>初期値 a0 </td></tr>
    <tr><td class="paramname">list</td><td>データが格納されたコンテナ [b]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果 a</dd></dl>
<dl class="section see"><dt>See also</dt><dd>foldr(F const&amp; func, T init, C const&amp; list)</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::set&lt;double&gt; data1{ -2.2, 0 , 1.1, 3.3 };</div>
<div class="line"><span class="keyword">const</span> array&lt;int, 4&gt; data2{ 1, -3, 5, 4 };   <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> r1 = <a class="code" href="namespacesig.html#ae66e7d0f082892a119563d6433ebdd91">foldl</a>(std::plus&lt;double&gt;(), 0, data1);</div>
<div class="line"><span class="keywordtype">double</span> r2 = <a class="code" href="namespacesig.html#ae66e7d0f082892a119563d6433ebdd91">foldl</a>([](<span class="keywordtype">double</span> sum, <span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> sum + v % 2; }, 0, data2);</div>
<div class="line"></div>
<div class="line">r1;     <span class="comment">// 2.2</span></div>
<div class="line">r2;     <span class="comment">// 1</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="fold_8hpp_source.html#l00043">43</a> of file <a class="el" href="fold_8hpp_source.html">fold.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3014145c596b086b3077e5c23079a5c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::foldr </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナの末尾からたたみ込み </p>
<p>(a -&gt; b -&gt; b) -&gt; b0 -&gt; [a] -&gt; b <br />
b0はbに暗黙的に型変換可能</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>関数 (a -&gt; b -&gt; a) </td></tr>
    <tr><td class="paramname">init</td><td>初期値 b0 </td></tr>
    <tr><td class="paramname">list</td><td>データが格納されたコンテナ [a]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果 b</dd></dl>
<dl class="section see"><dt>See also</dt><dd>foldl(F const&amp; func, T init, C const&amp; list)</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> fl = <a class="code" href="namespacesig.html#ae66e7d0f082892a119563d6433ebdd91">foldl</a>(std::minus&lt;int&gt;(), 1, array&lt;int, 3&gt;{ 2, 3, 4 }); <span class="comment">// ((1-2)-3)-4</span></div>
<div class="line"><span class="keywordtype">int</span> fr = <a class="code" href="namespacesig.html#a3014145c596b086b3077e5c23079a5c0">foldr</a>(std::minus&lt;int&gt;(), 4, array&lt;int, 3&gt;{ 1, 2, 3 });  <span class="comment">// 1-(2-(3-4))</span></div>
<div class="line"></div>
<div class="line">assert(fl0 == ((1-2)-3)-4);</div>
<div class="line">assert(fr0 == 1-(2-(3-4)));</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="fold_8hpp_source.html#l00074">74</a> of file <a class="el" href="fold_8hpp_source.html">fold.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accbb5a44357f4b1e66651f58ed4ff872"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::for_diagonal </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>行列の対角要素の対して、代入演算を行う関数を適用する </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00345">345</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5abdd94c780931a557c8a0ce94f5df3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::for_each </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>containers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>複数コンテナを反復処理 </p>
<p>先頭の要素から順番に関数を適用し、いずれかのコンテナの末尾に到達するまで繰り返す．<br />
適用する関数オブジェクトの引数を参照(&amp;)にすることで、値の変更が可能</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>関数オブジェクト(引数の順番は渡すcontainersの順番に対応) </td></tr>
    <tr><td class="paramname">containers</td><td>処理対象のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#af5abdd94c780931a557c8a0ce94f5df3" title="複数コンテナを反復処理 ">for_each</a>(F const&amp; func, int init, Cs&amp;&amp;... containers)</dd></dl>
<div class="fragment"><div class="line">array&lt;double, 4&gt; data1{ 1.1, 2.2, 3.3, 4.4 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;int&gt; data2{ 1, -3, 5 };</div>
<div class="line"><span class="keyword">const</span> std::multiset&lt;std::string&gt; data3{ <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bb&quot;</span>, <span class="stringliteral">&quot;ccc&quot;</span> };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#af5abdd94c780931a557c8a0ce94f5df3">for_each</a>([](<span class="keywordtype">double</span>&amp; a, <span class="keywordtype">int</span> b, std::string <span class="keyword">const</span>&amp; s)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> tmp = b + <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(s.length());</div>
<div class="line">    a += tmp;</div>
<div class="line">},</div>
<div class="line">    data1, data2, data3</div>
<div class="line">);</div>
<div class="line"></div>
<div class="line">data1;      <span class="comment">// { 3.1, 1.2, 11.3, 4.4 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="for__each_8hpp_source.html#l00046">46</a> of file <a class="el" href="for__each_8hpp_source.html">for_each.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf79f48e708a89d327561f7aa7cf36e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::for_each </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>containers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>複数コンテナを反復処理 (添字変数の利用可) </p>
<p>1反復毎に1ずつインクリメントされる添字変数を利用可 (initはその初期値). <br />
先頭の要素から順番に関数を適用し、いずれかのコンテナの末尾に到達するまで繰り返す．<br />
引数で渡す関数オブジェクト(orラムダ)の引数を参照(&amp;)にすることで変更操作も可能</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>関数オブジェクト(第1引数は添字変数.以降の引数の順番は渡すcontainersの順番に対応) </td></tr>
    <tr><td class="paramname">init</td><td>添字変数の初期値 </td></tr>
    <tr><td class="paramname">containers</td><td>処理対象のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; data1{ 1, -3, 5 };</div>
<div class="line"><span class="keyword">const</span> std::list&lt;double&gt; data2{ 1.0, -3.0, 5.0 };</div>
<div class="line"><span class="keyword">const</span> std::multiset&lt;int, std::greater&lt;int&gt;&gt; data3{ 1, -3, 5 };</div>
<div class="line"><span class="keyword">const</span> std::map&lt;int, char&gt; data4{ {0, <span class="charliteral">&#39;a&#39;</span>}, {1, <span class="charliteral">&#39;b&#39;</span>}, {2, <span class="charliteral">&#39;c&#39;</span>}, {3, <span class="charliteral">&#39;d&#39;</span>} };</div>
<div class="line">array&lt;std::string, 3&gt; data5{ <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;C&quot;</span> };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#af5abdd94c780931a557c8a0ce94f5df3">for_each</a>([](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">int</span> c, <span class="keywordtype">char</span> d, std::string&amp; e)</div>
<div class="line">{</div>
<div class="line">    e.append(std::to_string(i) + std::to_string(a + b) + d + std::to_string(c));</div>
<div class="line">},</div>
<div class="line">    -1, data1, data2, data3, data4, data5</div>
<div class="line">);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="for__each_8hpp_source.html#l00078">78</a> of file <a class="el" href="for__each_8hpp_source.html">for_each.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a94dff9939ed9ec88dfe5d130a00996d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::for_each_m </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>行列の全要素に対して、代入演算を行う関数を適用する </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00331">331</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86fa2c9c6a36079d0a02fda6ecf976a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class V , class... Vs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::for_each_v </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ベクトルの全要素に対して、関数を適用する </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00323">323</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a872c65543565cbb8e0b5ac8fbaa5d9d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class R  = std::vector&lt;typename M::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::from_matrix_ublas </td>
          <td>(</td>
          <td class="paramtype">M const &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; R
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ublas::matrix&lt;T&gt; の指定行を STLのvectorへ変換 </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00128">128</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11d322da9f344715e8b9839dd5704321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M , class R  = std::vector&lt;std::vector&lt;typename M::value_type&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::from_matrix_ublas </td>
          <td>(</td>
          <td class="paramtype">M const &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td> -&gt; R
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ublas::matrix&lt;T&gt; から STLのvectorの2次元配列へ変換 </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00141">141</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeae5dc89c97a55b722f9c2187e1383ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class R  = std::vector&lt;typename V::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::from_vector_ublas </td>
          <td>(</td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> -&gt; R
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ublas::vector&lt;T&gt; から STLのvectorへ変換 </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00115">115</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f20e072bf9d74747a86b1e966cbc75b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; sig::fromJust </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Justから値を取り出す関数．Maybe a -&gt; a. </p>
<p>Maybeの正体がNothingオブジェクトの場合、未定義動作</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#ae2258dc44d08856ce1045788dba03cf0" title="fromJust演算子 ">operator*(Maybe&lt;T&gt;&amp; m)</a></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = Just&lt;int&gt;(1);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cm = Just&lt;int&gt;(2);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> v1 = <a class="code" href="namespacesig.html#a7f20e072bf9d74747a86b1e966cbc75b">fromJust</a>(m);       <span class="comment">// v == 1</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span>&amp; v2 = <a class="code" href="namespacesig.html#a7f20e072bf9d74747a86b1e966cbc75b">fromJust</a>(m);     <span class="comment">// int&amp;</span></div>
<div class="line">rv = 5;</div>
<div class="line">assert(*m == 5);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span>&amp; v3 = <a class="code" href="namespacesig.html#a7f20e072bf9d74747a86b1e966cbc75b">sig::fromJust</a>(cm);   <span class="comment">// const int&amp;</span></div>
<div class="line"><span class="keyword">auto</span> v4 = <a class="code" href="namespacesig.html#a7f20e072bf9d74747a86b1e966cbc75b">sig::fromJust</a>(cm);    <span class="comment">// int</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00113">113</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3ba761c62ff7410bc36ba4125fc52a9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; sig::fromJust </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00114">114</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53c9838fe59cffe3c0e4eadaffaa10ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp;&amp; sig::fromJust </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00115">115</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f8aec50cdb37b41e7660ce47eb94668"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; sig::fromMaybe </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Maybe&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maybeから値を取り出す関数．もしNothingなら引数のデフォルト値を返す．a -&gt; Maybe a -&gt; a. </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = Just&lt;int&gt;(1);</div>
<div class="line"><span class="keyword">auto</span> n = <a class="code" href="namespacesig.html#a25cb201c09c499316f1bad72f8373a16">Nothing</a>(0);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> v = <a class="code" href="namespacesig.html#a8f8aec50cdb37b41e7660ce47eb94668">fromMaybe</a>(2, m);    <span class="comment">// v == 1</span></div>
<div class="line"><span class="keywordtype">int</span> d = <a class="code" href="namespacesig.html#a8f8aec50cdb37b41e7660ce47eb94668">fromMaybe</a>(2, n);    <span class="comment">// d == 2</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00145">145</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af55d131e28fddf951e625266728da64f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; sig::fromMaybe </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Maybe&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00146">146</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abad06d86e8c02e2e92915836f5f9bcc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp;&amp; sig::fromMaybe </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Maybe&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00147">147</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50d86afec32c12c4b25c6954bb062321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp;&amp; sig::fromMaybe </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::none_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00148">148</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add9641221a9d6b8501706996e9dd0af6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CC1 , class CC2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::GaleShapley </td>
          <td>(</td>
          <td class="paramtype">CC1 const &amp;&#160;</td>
          <td class="paramname"><em>men_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CC2 const &amp;&#160;</td>
          <td class="paramname"><em>women_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="others_8hpp_source.html#l00058">58</a> of file <a class="el" href="others_8hpp_source.html">others.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af42cbe8ff98d33c0fed0272719afab98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::get_file_names </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>directory_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hidden_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::wstring&#160;</td>
          <td class="paramname"><em>extension</em> = <code>L&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;std::vector&lt;std::wstring&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指定ディレクトリにあるファイル名を取得 </p>
<dl class="section pre"><dt>Precondition</dt><dd>VisualStudio環境 または boostのインクルード</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directry_pass</td><td>調べたいディレクトリのパス </td></tr>
    <tr><td class="paramname">hidden_file</td><td>true:隠しファイルのみ, false:非隠しファイルのみ (Windows, Linux環境のみ) </td></tr>
    <tr><td class="paramname">extension</td><td>[option] 拡張子指定</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ファイル名の一覧 </dd></dl>

<p>Definition at line <a class="el" href="pass_8hpp_source.html#l00075">75</a> of file <a class="el" href="pass_8hpp_source.html">pass.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15fc92d32cb757b35820c70eeff4b0a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::get_folder_names </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>directory_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hidden_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;std::vector&lt;std::wstring&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指定ディレクトリにあるフォルダ名を取得 </p>
<dl class="section pre"><dt>Precondition</dt><dd>VisualStudio環境 または boostのインクルード</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directry_pass</td><td>調べたいディレクトリのパス </td></tr>
    <tr><td class="paramname">hidden_file</td><td>true:隠しファイルのみ, false:非隠しファイルのみ (Windows, Linux環境のみ)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>フォルダ名の一覧 </dd></dl>

<p>Definition at line <a class="el" href="pass_8hpp_source.html#l00143">143</a> of file <a class="el" href="pass_8hpp_source.html">pass.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acecfcffc04df3603a6fd003dd2c11bf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sig::greater </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>v1 &gt; v2 であるか確認</p>
<div class="fragment"><div class="line">static_assert( <a class="code" href="namespacesig.html#acecfcffc04df3603a6fd003dd2c11bf6">greater</a>(1, 0), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00387">387</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2b044b8daf4cb6bde169e41b9a7ac80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::has_zero </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>要素の値に0があるか確認 </p>

<p>Definition at line <a class="el" href="comparable__check_8hpp_source.html#l00038">38</a> of file <a class="el" href="comparable__check_8hpp_source.html">comparable_check.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6daf188e62e3ea0683467a59fb7ec427"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::invert_matrix </td>
          <td>(</td>
          <td class="paramtype">matrix_u&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td> -&gt; Maybe&lt;matrix_u&lt;RT&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>逆行列を求める </p>
<p>LU分解を用いて逆行列を計算する．<br />
boost.optional有効時には値がラップされて返される</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>逆行列を求める行列．この行列自体に変更を加えても良い場合はmoveで渡す</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>逆行列 </dd></dl>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00204">204</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7744371e6137a1870712b81789db204f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::invert_matrix </td>
          <td>(</td>
          <td class="paramtype">matrix_u&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td> -&gt; Maybe&lt;matrix_u&lt;RT&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00223">223</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64ba038deca2879296c8a5dfe8c3ed42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C1 , class C2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::is_comparable </td>
          <td>(</td>
          <td class="paramtype">C1 const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::NumericVectorTag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2つのベクトルが比較可能か確認 </p>

<p>Definition at line <a class="el" href="comparable__check_8hpp_source.html#l00045">45</a> of file <a class="el" href="comparable__check_8hpp_source.html">comparable_check.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acad83f9796b7cc733121dd6bd819f8f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C1 , class C2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::is_comparable </td>
          <td>(</td>
          <td class="paramtype">C1 const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::DistributionTag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2つの確率分布が比較可能か確認 </p>

<p>Definition at line <a class="el" href="comparable__check_8hpp_source.html#l00052">52</a> of file <a class="el" href="comparable__check_8hpp_source.html">comparable_check.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad899ab2bb7357039a1201c7b8d55837a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sig::is_finite_number </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値が非数(NaN)でなく、かつ無限大(Inf)でないかを確認 </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> inf = std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line"><span class="keywordtype">double</span> inf2 = <a class="code" href="namespacesig.html#a74f9ef4103b6e5e2d6f961a6e23fd231">product</a>(sig::replicate&lt;double&gt;(1000, 10));    <span class="comment">// 10^1000</span></div>
<div class="line"></div>
<div class="line">assert(<a class="code" href="namespacesig.html#ad899ab2bb7357039a1201c7b8d55837a">is_finite_number</a>(0));</div>
<div class="line">assert(!<a class="code" href="namespacesig.html#ad899ab2bb7357039a1201c7b8d55837a">is_finite_number</a>(inf));</div>
<div class="line">assert(!<a class="code" href="namespacesig.html#ad899ab2bb7357039a1201c7b8d55837a">is_finite_number</a>(inf2));</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00225">225</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6c4ff79023e00971f8e168cca5f9abf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sig::is_number </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値が非数(NaN)でないかを確認 </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> zero = 0;</div>
<div class="line"><span class="keywordtype">double</span> nan = std::numeric_limits&lt;double&gt;::quiet_NaN();</div>
<div class="line"></div>
<div class="line">assert(<a class="code" href="namespacesig.html#ab6c4ff79023e00971f8e168cca5f9abf">is_number</a>(0));</div>
<div class="line">assert(!<a class="code" href="namespacesig.html#ab6c4ff79023e00971f8e168cca5f9abf">is_number</a>(nan));</div>
<div class="line">assert(!<a class="code" href="namespacesig.html#ab6c4ff79023e00971f8e168cca5f9abf">is_number</a>(zero/zero));</div>
<div class="line">assert(!<a class="code" href="namespacesig.html#ab6c4ff79023e00971f8e168cca5f9abf">is_number</a>(std::sqrt(-1)));</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00207">207</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52814e765c5470736aaf284cd0d87bba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C1 , class C2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::is_same_size </td>
          <td>(</td>
          <td class="paramtype">C1 const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="comparable__check_8hpp_source.html#l00023">23</a> of file <a class="el" href="comparable__check_8hpp_source.html">comparable_check.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a710d902f8cf49353c7777f88af537c63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C1 , class C2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::is_valid_distribution </td>
          <td>(</td>
          <td class="paramtype">C1 const &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 const &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>離散確率分布の性質を満たしているか確認 </p>

<p>Definition at line <a class="el" href="comparable__check_8hpp_source.html#l00030">30</a> of file <a class="el" href="comparable__check_8hpp_source.html">comparable_check.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a675208b02facbcec0e0d33e2749494e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::isJust </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Justであるか調べる関数．Maybe a -&gt; Bool. </p>

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00084">84</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeaa56e575f888c003428d605f6b2f0bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sig::isJust </td>
          <td>(</td>
          <td class="paramtype">boost::none_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00085">85</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf53abaf9b45b9d4f47c88ef413c9163"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::isNothing </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nothingであるか調べる関数．Maybe a -&gt; Bool. </p>

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00089">89</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca826f173fe26af455e4e6235d6f357c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sig::isNothing </td>
          <td>(</td>
          <td class="paramtype">boost::none_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00090">90</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42789077fe53ae36d43aaa4fc60c5e51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Its&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::iterative_assign </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Its...&#160;</td>
          <td class="paramname"><em>iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00197">197</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0534a7c631ef0cf5355d7feb38b1c5dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... Its&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::iterative_assign </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Its...&#160;</td>
          <td class="paramname"><em>iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00204">204</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c977dd2ef479d3f036f578b97a22670"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F1 , class F2 , class... Its&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::iterative_fold </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>zip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Its...&#160;</td>
          <td class="paramname"><em>iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00187">187</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41d6496e85265c98d7abeb0d76102576"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class F , class... Its&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::iterative_make </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Its...&#160;</td>
          <td class="paramname"><em>iterators</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="container__helper_8hpp_source.html#l00178">178</a> of file <a class="el" href="container__helper_8hpp_source.html">container_helper.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1fafa5a56df7a8b5e949ee830ef2999c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class R  = typename sig::impl::remove_const_reference&lt;T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt;R&gt; sig::Just </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値コンストラクタ </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m1 = <a class="code" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">Just</a>(1);          <span class="comment">// :: Maybe&lt;int&gt;</span></div>
<div class="line"><span class="keyword">auto</span> m2 = Just&lt;double&gt;(1);  <span class="comment">// :: Maybe&lt;double&gt;</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00055">55</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a55f0cba1ae0e36816871c69a0d7ea931"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesig.html#ac7ec5a8e01f01010a96578cdc817cd26">Maybe</a>&lt;T&gt; sig::Just </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00058">58</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd23e1f1e05a7d8abb0555fe019f2460"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool sig::less </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>v1 &lt; v2 であるか確認</p>
<div class="fragment"><div class="line">static_assert( <a class="code" href="namespacesig.html#afd23e1f1e05a7d8abb0555fe019f2460">less</a>(0, 1), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00397">397</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aece976557907baf76250e2da7c136660"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IFS_CHAR , class C , class R  = typename impl::container_traits&lt;C&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::load_line </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_ifstream&lt; IFS_CHAR &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルから1行ずつ読み込む（ifstreamを指定） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_dest</td><td>保存先のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ) </td></tr>
    <tr><td class="paramname">ifs</td><td>std::ifstream or std::wifstream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み込みの成否 </dd></dl>

<p>Definition at line <a class="el" href="load_8hpp_source.html#l00052">52</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aea20e0cd765952c183f90073eb3428bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class R  = typename impl::container_traits&lt;C&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::load_line </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルから1行ずつ読み込む（ファイル名を指定） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_dest</td><td>保存先のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ) </td></tr>
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み込みの成否</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line">std::vector&lt;std::string&gt; input;</div>
<div class="line"><a class="code" href="namespacesig.html#aece976557907baf76250e2da7c136660">load_line</a>(input, fpass);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="load_8hpp_source.html#l00085">85</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e78169e5be4b7762ecab3937a0274d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ISTR  = std::string, class C  = std::vector&lt;ISTR&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::load_line </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em></td><td>)</td>
          <td> -&gt; Maybe&lt;C&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルから1行ずつ読み込み、結果を返す（ファイル名を指定） </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ISTR</td><td>[option] 読み込んだ文字列を保持する型（std::string or std::wstring）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_pass</td><td>読み込むファイルのパス</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み込み結果（値は<a class="el" href="sig_maybe.html">Maybe</a> で返される）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> input = <a class="code" href="namespacesig.html#aece976557907baf76250e2da7c136660">load_line</a>(fpass);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span>&amp; data = *input;        <span class="comment">// std::vector&lt;std::string&gt;</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="load_8hpp_source.html#l00137">137</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b493c09afd9a058d5a7863aa036c147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ISTR  = std::string, class R  = ISTR, class C  = std::vector&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::load_line </td>
          <td>(</td>
          <td class="paramtype">FilepassStringC&#160;</td>
          <td class="paramname"><em>file_pass</em></td><td>)</td>
          <td> -&gt; Maybe&lt;C&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>file_pass が const char* , const wcahr_t* である場合のオーバーロード</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#a0e78169e5be4b7762ecab3937a0274d3" title="ファイルから1行ずつ読み込み、結果を返す（ファイル名を指定） ">load_line(FilepassString const&amp; file_pass)</a> </dd></dl>

<p>Definition at line <a class="el" href="load_8hpp_source.html#l00162">162</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5db0c96ded610e9b029bdf192de1dcb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IFS_CHAR , class F , class C , class R  = typename impl::container_traits&lt;C&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::load_line </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_ifstream&lt; IFS_CHAR &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>conv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルから1行ずつ読み込み、同時に変換処理を行う（ifstreamを指定） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_dest</td><td>保存先のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ) </td></tr>
    <tr><td class="paramname">ifs</td><td>std::ifstream or std::wifstream </td></tr>
    <tr><td class="paramname">conv</td><td>読み込んだ文字列から任意型Rへの変換関数(文字列 -&gt; 数値型へはload_numを推奨) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="load_8hpp_source.html#l00183">183</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ffb973fb3d164d1ec5c65b22ffecc47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ISTR  = std::string, class F , class C , class R  = typename impl::container_traits&lt;C&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::load_line </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>conv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルから1行ずつ読み込み、同時に変換処理を行う（ファイル名を指定） </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ISTR</td><td>[option] 読み込んだ文字列を保持する型（std::string or std::wstring）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_dest</td><td>保存先のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ) </td></tr>
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">conv</td><td>読み込んだ文字列から任意型Rへの変換関数(文字列 -&gt; 数値型へはload_numを推奨)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Test{</div>
<div class="line">    <span class="keywordtype">int</span> a;</div>
<div class="line">    Test(<span class="keywordtype">double</span> v, <span class="keywordtype">double</span> p) : a(std::pow(v, p)){}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line">std::vector&lt;Test&gt; input;</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#aece976557907baf76250e2da7c136660">load_line</a>(</div>
<div class="line">    input,</div>
<div class="line">    fpass,</div>
<div class="line">    [&amp;](std::string&amp;&amp; s){</div>
<div class="line">        <span class="keyword">auto</span> tmp = <a class="code" href="namespacesig.html#ac4c8c4feeb72922c1e9075d8e26a1bc5">split</a>(s, <span class="stringliteral">&quot;,&quot;</span>);       <span class="comment">// example: s = &quot;2.73,0.001&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> Test(tmp[0], tmp[1]);</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="load_8hpp_source.html#l00233">233</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07036bf2289ae139bb6cc04d7d9067bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class RT  = typename impl::container_traits&lt;C&gt;::value_type, typename std::enable_if&lt;!impl::container_traits&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::load_num </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>数値列を読み込む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_dest</td><td>保存先のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ) </td></tr>
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">delimiter</td><td>[option] 数値間の区切り文字</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み込みの成否</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument（数値に変換できない場合）,std::out_of_range（intやdouble等で変換可能な値の範囲を超えている場合）</td><td>n</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass1 = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test1.txt&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass2 = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test2.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line">std::vector&lt;double&gt; input1;</div>
<div class="line">std::set&lt;double&gt; input2;</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#a07036bf2289ae139bb6cc04d7d9067bc">load_num</a>(input1, fpass1);</div>
<div class="line"><a class="code" href="namespacesig.html#a07036bf2289ae139bb6cc04d7d9067bc">load_num</a>(input2, fpass2, <span class="stringliteral">&quot;,&quot;</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test1.txt</span></div>
<div class="line">1.1</div>
<div class="line">2.2</div>
<div class="line">3.3</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test2.txt</span></div>
<div class="line">1.1,2.2,3.3</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="load_8hpp_source.html#l00293">293</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6df3d6dbc99465ff05675f4481d19946"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class C  = std::vector&lt;R&gt;, typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &amp;&amp;!impl::container_traits&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::load_num </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;C&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>数値列を読み込み、結果を返す </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>数値の型（int, double等） </td></tr>
    <tr><td class="paramname">C</td><td>[option] コンテナの型（<a class="el" href="sig_container.html">対応コンテナ</a> )</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">delimiter</td><td>[option] 数値間の区切り文字</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み込み結果（値は<a class="el" href="sig_maybe.html">Maybe</a> で返される）</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument（数値に変換できない場合）,std::out_of_range（intやdouble等で変換可能な値の範囲を超えている場合）</td><td>n</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass1 = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test1.txt&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass2 = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test2.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> input1 = load_num&lt;double&gt;(fpass1);</div>
<div class="line"><span class="keyword">auto</span> input2 = load_num&lt;double, std::set&lt;double&gt;&gt;(fpass2, <span class="stringliteral">&quot;,&quot;</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test1.txt</span></div>
<div class="line">1.1</div>
<div class="line">2.2</div>
<div class="line">3.3</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test2.txt</span></div>
<div class="line">1.1,2.2,3.3</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="load_8hpp_source.html#l00351">351</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa795e9f5abad527ab43c501ad705b3b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CC , class RC  = typename impl::container_traits&lt;CC&gt;::value_type, class RT  = typename impl::container_traits&lt;RC&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::load_num2d </td>
          <td>(</td>
          <td class="paramtype">CC &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2次元配列の数値(ex:行列)を読み込む </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">empty_dest</td><td>保存先のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ) </td></tr>
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">delimiter</td><td>数値間の区切り文字</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み込みの成否</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument（数値に変換できない場合）,std::out_of_range（intやdouble等で変換可能な値の範囲を超えている場合）</td><td>n</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line">array&lt;std::vector&lt;int&gt;, 3&gt; input_mat;</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#aa795e9f5abad527ab43c501ad705b3b0">load_num2d</a>(input_mat, fpass, <span class="stringliteral">&quot;,&quot;</span>);</div>
<div class="line">assert(input_mat[2][0], 7);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test.txt</span></div>
<div class="line">1,2,3</div>
<div class="line">4,5,6,7</div>
<div class="line">8,9</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="load_8hpp_source.html#l00397">397</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbc87b5d90a8c04ce75e6d8e9636a7db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class CC  = std::vector&lt;std::vector&lt;R&gt;&gt;, typename std::enable_if&lt; impl::container_traits&lt; typename impl::container_traits&lt; CC &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::load_num2d </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;CC&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2次元配列の数値(ex:行列)を読み込む </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>数値の型（int, double等） </td></tr>
    <tr><td class="paramname">CC</td><td>[option] コンテナの型（<a class="el" href="sig_container.html">対応コンテナ</a> )</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">delimiter</td><td>数値間の区切り文字</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>読み込み結果（値は<a class="el" href="sig_maybe.html">Maybe</a> で返される）</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument（数値に変換できない場合）,std::out_of_range（intやdouble等で変換可能な値の範囲を超えている場合）</td><td>n</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> input_mat = load_num2d&lt;double&gt;(input_mat, fpass, <span class="stringliteral">&quot;,&quot;</span>);</div>
<div class="line">assert(input_mat[2][0], 7);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test.txt</span></div>
<div class="line">1,2,3</div>
<div class="line">4,5,6,7</div>
<div class="line">8,9</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="load_8hpp_source.html#l00450">450</a> of file <a class="el" href="load_8hpp_source.html">load.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab98f3fec5daa1616ea0157146a0eb1ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::make_regex </td>
          <td>(</td>
          <td class="paramtype">S const &amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td> -&gt; typename impl::Str2RegexSelector&lt;impl::string_t&lt;S&gt;&gt;::regex
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>エスケープ処理を行い、regexオブジェクトを返す </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>正規表現の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::regex or std::wregex (libstdc++使用時 かつ boost使用時は boost::regex)</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> reg = <a class="code" href="namespacesig.html#ab98f3fec5daa1616ea0157146a0eb1ac">make_regex</a>(L<span class="stringliteral">&quot;(笑)&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// SIG_RegexReplace is std::regex_replace or boost::regex_replace</span></div>
<div class="line"><span class="keyword">auto</span> replaced = <a class="code" href="regex_8hpp.html#a3a14e560066c0a82451c515abc3080db">SIG_RegexReplace</a>(std::wstring(L<span class="stringliteral">&quot;てすと(笑)です&quot;</span>), reg, std::wstring(L<span class="stringliteral">&quot;&quot;</span>));</div>
<div class="line"></div>
<div class="line">assert(replaced == L<span class="stringliteral">&quot;てすとです&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="regex_8hpp_source.html#l00148">148</a> of file <a class="el" href="regex_8hpp_source.html">regex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a133e4efd41fbaef9d3c2b4f0a285edfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C  = std::vector&lt;int&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C sig::make_unique_numbers </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>重複の無い一様分布の整数乱数を生成 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>発生させる値の個数 </td></tr>
    <tr><td class="paramname">min</td><td>最小値 </td></tr>
    <tr><td class="paramname">max</td><td>最大値 </td></tr>
    <tr><td class="paramname">debug</td><td>乱数のシードを固定するか</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>生成した乱数を格納したコンテナ</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> rints = <a class="code" href="namespacesig.html#a133e4efd41fbaef9d3c2b4f0a285edfb">make_unique_numbers</a>(10, 0, 20, <span class="keyword">true</span>);  <span class="comment">// [0, 20]の一様分布から10個重複無くサンプル</span></div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> v : rints) std::cout &lt;&lt; v &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="random_8hpp_source.html#l00085">85</a> of file <a class="el" href="random_8hpp_source.html">random.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac97756ac3daaf2bbeb544278148c960a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::map </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1引数高階関数 </p>
<p>(a -&gt; b) -&gt; [a] -&gt; [b] <br />
コンテナの各要素に関数を適用し、結果を新たなコンテナに格納する</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>関数 (a -&gt; b) </td></tr>
    <tr><td class="paramname">list</td><td>データが格納されたコンテナ [a]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果のコンテナ [b]（コンテナはlistと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 3&gt; data1{ 1, -3, 5 };  <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::unordered_set&lt;double&gt; data2{ 0, 1.1, -2.2, 3.3 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> r1 = <a class="code" href="namespacesig.html#ac97756ac3daaf2bbeb544278148c960a">map</a>(increment_t(), data1);</div>
<div class="line"><span class="keyword">auto</span> r2 = <a class="code" href="namespacesig.html#ac97756ac3daaf2bbeb544278148c960a">map</a>([](<span class="keywordtype">double</span> v){ <span class="keywordflow">return</span> v * 2; }, data2);</div>
<div class="line"></div>
<div class="line">r1;     <span class="comment">// array&lt;int, 3&gt;{ 2, -2, 6 }</span></div>
<div class="line">r2;     <span class="comment">// std::unordered_set&lt;double&gt;{ 0, 2.2, -4.4, 6.6 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="high__order_8hpp_source.html#l00062">62</a> of file <a class="el" href="high__order_8hpp_source.html">high_order.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaeaa8a6e1a0434efc742c8ddcc689d16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::map_m </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00302">302</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e485d9f2c529f6307b98b54d0c1b253"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::map_v </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ベクトルの全要素に対して、値を返す関数を適用し、その結果のベクトルを返す </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00287">287</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ab453d7332268dc96edbd8db46bf249"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::mapMaybe </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::container_traits&lt;C&gt;::template rebind&lt;
			typename std::remove_reference&lt;decltype(*(impl::eval(
				f, 
				std::declval&lt;typename impl::container_traits&lt;C&gt;::value_type&gt;()
			)))&gt;::type
		&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maybeを返す関数を指定するfilter関数．(a -&gt; Maybe b) -&gt; [a] -&gt; [b]. </p>
<p>コンテナの各要素にMaybeを返す関数を適用し、結果がJustであれば値を保存し、Nothingであれば無視する</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Maybeを返す関数 </td></tr>
    <tr><td class="paramname">list</td><td><a class="el" href="sig_container.html">対応コンテナ</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果を格納したlistと同じ種類のコンテナ</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec{ 1, 2, 3 };</div>
<div class="line"><span class="keyword">auto</span> vecd = <a class="code" href="namespacesig.html#a7ab453d7332268dc96edbd8db46bf249">mapMaybe</a>([](<span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> v != 2 ? Just&lt;double&gt;(v *1.5) : <a class="code" href="namespacesig.html#a25cb201c09c499316f1bad72f8373a16">Nothing</a>(0); }, vec);</div>
<div class="line">vecd[0];        <span class="comment">// 1.5</span></div>
<div class="line">vecd[1];        <span class="comment">// 4.5</span></div>
<div class="line">vecf[2];        <span class="comment">// out of range. undefined behavior</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00168">168</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb981bcfc924c08db74f1ff900e34555"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::matrix_vector_solve </td>
          <td>(</td>
          <td class="paramtype">matrix_u&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_u&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;vector_u&lt;RT&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>連立方程式を解く </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00236">236</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59c5a1934d6c2113643d688acd571e68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::matrix_vector_solve </td>
          <td>(</td>
          <td class="paramtype">matrix_u&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_u&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;vector_u&lt;RT&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00253">253</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae5130e58654a9d4e71e90e0b898e5274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::matrix_vector_solve </td>
          <td>(</td>
          <td class="paramtype">matrix_u&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_u&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;vector_u&lt;RT&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00265">265</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2ebfe1d6033e95bebbcbc99670e504a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class RT  = typename std::conditional&lt;std::is_integral&lt;T&gt;::value, double, T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::matrix_vector_solve </td>
          <td>(</td>
          <td class="paramtype">matrix_u&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector_u&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;vector_u&lt;RT&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00276">276</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab27dcfc67c86de4742fb2879c566805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00160">160</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a316477a2011e24c3ac76d177da8892e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::max </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00169">169</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2bf056a93660f704250522f3a38ce08a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>可変長 max </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v,vs</td><td>大小比較可能な変数（数値を表すPOD型 または operator &lt; が定義されたオブジェクト）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>最大の要素</dd></dl>
<div class="fragment"><div class="line">static_assert( <a class="code" href="namespacesig.html#aab27dcfc67c86de4742fb2879c566805">max</a>(1, -1, 0, 3, 2) == 3, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00188">188</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0983ab48709aa9ac662fb3e950580a0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class R  = typename impl::remove_const_reference&lt;C&gt;::type, typename std::enable_if&lt;!impl::static_container_traits&lt; R &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::merge </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; R
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナの結合（同じコンテナ型） </p>
<p>[a] -&gt; [a] -&gt; [a] <br />
非シーケンスコンテナの場合、結合後の要素の順番は保たれない</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list1</td><td>結合後に前に位置するコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">list2</td><td>結合後に後ろに位置するコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナ（コンテナはlist1と同じ種類）</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#a00eb3681044e6af60a224d97c089920a">merge(C1&amp;&amp; list1, C2&amp;&amp; list2)</a></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 3&gt; data1{ 1, 2, 3 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> array&lt;int, 3&gt; data2{ 4, 5, 6 };       <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> m = <a class="code" href="namespacesig.html#a0983ab48709aa9ac662fb3e950580a0c">merge</a>(data1, data2);   <span class="comment">// array&lt;int, 6&gt;{ 1, 2, 3, 4 , 5, 6 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="list__deal_8hpp_source.html#l00094">94</a> of file <a class="el" href="list__deal_8hpp_source.html">list_deal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a00eb3681044e6af60a224d97c089920a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class C1 , class C2 , class CR1  = typename impl::remove_const_reference&lt;C1&gt;::type, class CR2  = typename impl::remove_const_reference&lt;C2&gt;::type, class RT  = typename std::common_type&lt;		typename impl::container_traits&lt;CR1&gt;::value_type,		typename impl::container_traits&lt;CR2&gt;::value_type	&gt;::type, class RR  = typename impl::SameIf&lt;R, void,		typename impl::remove_const_reference&lt; typename impl::container_traits&lt;CR1&gt;::template rebind&lt;RT&gt;&gt;::type,		R	&gt;::type, class AT1  = typename impl::forward_element&lt;C1&gt;::type, class AT2  = typename impl::forward_element&lt;C2&gt;::type, typename std::enable_if&lt;!(impl::static_container_traits&lt; CR1 &gt;::exist)&gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::merge </td>
          <td>(</td>
          <td class="paramtype">C1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; RR
</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[a] -&gt; [b] -&gt; [c] <br />
ただし、cはstd::common_type&lt;a, b&gt;::type <br />
非シーケンスコンテナの場合、結合後の要素の順番は保たれない</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>[option] 返り値のコンテナ型を指定（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list1</td><td>結合後に前に位置するコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">list2</td><td>結合後に後ろに位置するコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナ（コンテナは R もしくは list1と同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 4&gt; data1{ 1, 2, 3, 4 };        <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> array&lt;double, 3&gt; data2{ 5.5, 6.6, 7.7 };  <span class="comment">// sig::array</span></div>
<div class="line">std::vector&lt;int&gt; data3{ 1, -3 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> m1 = <a class="code" href="namespacesig.html#a0983ab48709aa9ac662fb3e950580a0c">merge</a>(data1, data2);      <span class="comment">// array&lt;double, 7&gt;{ 1, 2, 3, 4, 5.5, 6.6, 7.7 }</span></div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code" href="namespacesig.html#a0983ab48709aa9ac662fb3e950580a0c">merge</a>(data2, data3);      <span class="comment">// std::vector&lt;double&gt;{ 5.5, 6.6, 7.7, 1, -3 }</span></div>
<div class="line"><span class="keyword">auto</span> m3 = merge&lt;std::set&lt;double, std::greater&lt;double&gt;&gt;&gt;(data1, data2);  <span class="comment">// std::set&lt;double&gt;{ 7.7, 6.6, 5.5, 4, 3, 2, 1 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="list__deal_8hpp_source.html#l00163">163</a> of file <a class="el" href="list__deal_8hpp_source.html">list_deal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b33214c63c54016a89451fa17eae71f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class SC , class C , class SCR  = typename impl::remove_const_reference&lt;SC&gt;::type, class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class RT  = typename std::common_type&lt;		typename impl::static_container_traits&lt;SCR&gt;::value_type,		typename impl::container_traits&lt;CR&gt;::value_type	&gt;::type, class RR  = typename impl::SameIf&lt;R, void,		typename impl::remove_const_reference&lt; typename impl::container_traits&lt;CR&gt;::template rebind&lt;RT&gt;&gt;::type,		R	&gt;::type, typename std::enable_if&lt; impl::static_container_traits&lt; SCR &gt;::exist &amp;&amp;(!impl::static_container_traits&lt; CR &gt;::exist)&gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::merge </td>
          <td>(</td>
          <td class="paramtype">SC &amp;&amp;&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; RR
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="list__deal_8hpp_source.html#l00181">181</a> of file <a class="el" href="list__deal_8hpp_source.html">list_deal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aedd3d3a7a12295f72fefd798f29f596f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class SC1 , class SC2 , class SCR1  = typename impl::remove_const_reference&lt;SC1&gt;::type, class SCR2  = typename impl::remove_const_reference&lt;SC2&gt;::type, class RT  = typename std::common_type&lt;		typename impl::static_container_traits&lt;SCR1&gt;::value_type,		typename impl::static_container_traits&lt;SCR2&gt;::value_type	&gt;::type, class RR  = typename impl::SameIf&lt;R, void,		typename impl::static_container_traits&lt;SCR1&gt;::template rebind_t&lt;RT, impl::plus_t&lt;impl::static_container_traits&lt;SCR1&gt;::size, impl::static_container_traits&lt;SCR2&gt;::size&gt;::value&gt;,		R	&gt;::type, typename std::enable_if&lt; impl::static_container_traits&lt; SCR1 &gt;::exist &amp;&amp;impl::static_container_traits&lt; SCR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::merge </td>
          <td>(</td>
          <td class="paramtype">SC1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SC2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; RR
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="list__deal_8hpp_source.html#l00199">199</a> of file <a class="el" href="list__deal_8hpp_source.html">list_deal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45c7cfeba4eb923ac22a289dccbef2a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; T
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00122">122</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaac92ca8f4e406fbfe25b85b81152a88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::min </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00131">131</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff29c80135045f3ad2a7bd1e148cd0b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>可変長 min </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v,vs</td><td>大小比較可能な変数（数値を表すPOD型 または operator &lt; が定義されたオブジェクト）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>最小の要素</dd></dl>
<div class="fragment"><div class="line">static_assert( <a class="code" href="namespacesig.html#a45c7cfeba4eb923ac22a289dccbef2a1">min</a>(1, -1, 0, 3, 2) == -1, <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00150">150</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a848ae8d0c6c4180fd26010b517996b1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::minus </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(binary_operation(minus_t(), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00135">135</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0015738aab7a37329d019d4e6cdd231"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::modify_dirpass_tail </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>directory_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>has_slash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; FilepassString
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ディレクトリ・ファイルパスの末尾に'/'or'\'があるかチェックし、付けるか外すかどうかを指定して反映 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory_pass</td><td>チェックするパスの文字列 </td></tr>
    <tr><td class="paramname">has_slash</td><td>末尾に'/'or'\'を付けるかどうか</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>修正したパスの文字列</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> pass = <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;../SigUtil/example&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> mpass = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>(pass, <span class="keyword">true</span>);   <span class="comment">// &quot;../SigUtil/example/&quot;</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="pass_8hpp_source.html#l00043">43</a> of file <a class="el" href="pass_8hpp_source.html">pass.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2759ddda5fc4a3f04dddb08c2b6f7926"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::modify_range </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U const &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値を範囲内に自動修正 </p>
<p>min ≦ val ≦ max であるか確認し、範囲を超えている場合は最も近い範囲内の値（min または max）に修正</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>確認したい値 </td></tr>
    <tr><td class="paramname">min</td><td>範囲の下限 </td></tr>
    <tr><td class="paramname">max</td><td>範囲の上限</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>valが修正されたか</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> mr = 5;</div>
<div class="line">assert(<a class="code" href="namespacesig.html#a2759ddda5fc4a3f04dddb08c2b6f7926">sig::modify_range</a>(mr, 0, 10));</div>
<div class="line">assert(mr == 5);</div>
<div class="line">assert(!<a class="code" href="namespacesig.html#a2759ddda5fc4a3f04dddb08c2b6f7926">sig::modify_range</a>(mr, 0, 3));</div>
<div class="line">assert(mr == 3);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00371">371</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9164b021578416e243c0d04ef70ba5a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::mult </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(binary_operation(mult_t(), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00143">143</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a035b71dfb549484757f7ea4361980db8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; std::is_floating_point&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::normalize </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>正規化（Normalization） </p>
<p>最小値0、最大値1とし、各値が[0,1]の範囲に収まるように正規化.<br />
normalize(C const&amp; data, int dummy = 0)ではなくこちらが呼び出されているかを確認するには、返り値をboolで受けるようにする</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>正規化を行いたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）．要素型は浮動小数点型であることが条件</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>なし</dd></dl>
<div class="fragment"><div class="line">array&lt;double, 5&gt; ar{ -5, -2, 0, 1, 5 }; <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ck = <a class="code" href="namespacesig.html#a035b71dfb549484757f7ea4361980db8">normalize</a>(ar);</div>
<div class="line">ar;             <span class="comment">// { 0, 0.3, 0.5, 0.6, 1 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00266">266</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e2a5fbd16f092be471f46c4e801b1e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class C  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::normalize </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dummy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::container_traits&lt;C&gt;::template rebind&lt;R&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>正規化（Normalization） </p>
<p>最小値0、最大値1とし、各値が[0,1]の範囲に収まるように正規化． <a class="el" href="namespacesig.html#a035b71dfb549484757f7ea4361980db8" title="正規化（Normalization） ">normalize(C&amp; data)</a>ではなく明示的にこちらを呼び出す場合は、第2引数を指定</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>正規化を行いたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>正規化を行った結果</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;double, 5&gt; ar1{ -5, -1.5, 0, 0.5, 5 };      <span class="comment">// sig::array</span></div>
<div class="line">array&lt;double, 5&gt; ar2{ -5, -1.5, 0, 0.5, 5 };            <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> normal1 = <a class="code" href="namespacesig.html#a035b71dfb549484757f7ea4361980db8">normalize</a>(ar1);          <span class="comment">// { 0, 0.35, 0.5, 0.55, 1 }</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// 第2引数はダミー(ar2はconstでないため、オーバーロード解決でこの関数を呼び出すために必要)</span></div>
<div class="line"><span class="keyword">auto</span> normal2 = <a class="code" href="namespacesig.html#a035b71dfb549484757f7ea4361980db8">normalize</a>(ar2, 0);       <span class="comment">// { 0, 0.35, 0.5, 0.55, 1 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00303">303</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3fc69c56a1b13e60bda99520e131450"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; std::is_floating_point&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::normalize_dist </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確率分布の正規化 </p>
<p>各値の総和が1になるよう[0,1]の範囲に正規化.<br />
normalize_dist(C const&amp; data, int dummy = 0)ではなくこちらが呼び出されているかを確認するには、返り値をboolで受けるようにする</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>正規化を行いたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）．要素型は浮動小数点型であることが条件</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>なし</dd></dl>
<div class="fragment"><div class="line">array&lt;double, 5&gt; ar{ 1, 2, 4, 2, 1 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ck = <a class="code" href="namespacesig.html#af3fc69c56a1b13e60bda99520e131450">normalize_dist</a>(ar);</div>
<div class="line">ar;         <span class="comment">// { 0.1, 0.2, 0.4, 0.2, 0.1 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00394">394</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a376b90f17fefe3aa21f2f0a6bdb490f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class C  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::normalize_dist </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dummy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::container_traits&lt;C&gt;::template rebind&lt;R&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>確率分布の正規化 </p>
<p>各値の総和が1になるよう[0,1]の範囲に正規化.<br />
<a class="el" href="namespacesig.html#af3fc69c56a1b13e60bda99520e131450" title="確率分布の正規化 ">normalize_dist(C&amp; data)</a>ではなく明示的にこちらを呼び出す場合は、第2引数を指定</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>正規化を行いたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>正規化を行った結果</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 5&gt; ar1{  1, 2, 4, 2, 1 };          <span class="comment">// sig::array</span></div>
<div class="line">array&lt;double, 5&gt; ar2{ 0.2, 0.5, 1.4, 0.3, 0.8 };    <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> nd1 = <a class="code" href="namespacesig.html#af3fc69c56a1b13e60bda99520e131450">normalize_dist</a>(ar1);         <span class="comment">// { 0.1, 0.2, 0.4, 0.2, 0.1 }</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// 第2引数はダミー(ar2はconstでないため、オーバーロード解決でこの関数を呼び出すために必要)</span></div>
<div class="line"><span class="keyword">auto</span> nd2 = <a class="code" href="namespacesig.html#af3fc69c56a1b13e60bda99520e131450">normalize_dist</a>(ar2, 0);      <span class="comment">// { 0.0625, 0.15625, 0.4375, 0.09375, 0.25 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00422">422</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f128f0d26540efea0ccda181a8dddd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , typename std::enable_if&lt; std::is_floating_point&lt; typename V::value_type &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::normalize_dist_v </td>
          <td>(</td>
          <td class="paramtype">V &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00360">360</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ae5d5370bbb239dbacf066b0e73607a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::normalize_dist_v </td>
          <td>(</td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dummy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00369">369</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a25cb201c09c499316f1bad72f8373a16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::Nothing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; typename impl::SameIf&lt;T, void, typename boost::none_t, Maybe&lt;T&gt;&gt;::type
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値コンストラクタ </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> n = <a class="code" href="namespacesig.html#a25cb201c09c499316f1bad72f8373a16">Nothing</a>(); <span class="comment">// :: Maybe&lt;int&gt;</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00067">67</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fd20c41ef1171b5379b5e6261be017a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::Nothing </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>dummy</em></td><td>)</td>
          <td> -&gt; Maybe&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値コンストラクタ </p>
<p>引数はダミー（optional無効時にも統一的に記述できるようにするために存在）</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> n = <a class="code" href="namespacesig.html#a25cb201c09c499316f1bad72f8373a16">Nothing</a>(0);    <span class="comment">// :: Maybe&lt;int&gt;</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00080">80</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2258dc44d08856ce1045788dba03cf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; sig::operator* </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fromJust演算子 </p>
<p>fromJust関数の演算子版．<br />
Maybeの正体がNothingオブジェクトの場合、未定義動作</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#a7f20e072bf9d74747a86b1e966cbc75b" title="Justから値を取り出す関数．Maybe a -> a. ">fromJust(Maybe&lt;T&gt;&amp; m)</a></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = Just&lt;int&gt;(1);</div>
<div class="line"><span class="keywordtype">int</span> v = *m;     <span class="comment">// v == 1</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00130">130</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5f93b97f665d79e5896411aab6eefe59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; sig::operator* </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00131">131</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a89f7c5b4c054412850c0728c87411850"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp;&amp; sig::operator* </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00132">132</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ec5d9cab44f8397325ecf8b842b26ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class TR1  = typename impl::remove_const_reference&lt;T1&gt;::type, class TR2  = typename impl::remove_const_reference&lt;T2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; TR1 &gt;::exist||impl::container_traits&lt; TR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(binary_operation(mult_t(), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00195">195</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac7c59c24b350c339662beca36cae6be4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class TR1  = typename impl::remove_const_reference&lt;T1&gt;::type, class TR2  = typename impl::remove_const_reference&lt;T2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; TR1 &gt;::exist||impl::container_traits&lt; TR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(binary_operation(plus_t(), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00165">165</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2f667ffc15f6dc1c3d94dc1f36db059"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class TR1  = typename impl::remove_const_reference&lt;T1&gt;::type, class TR2  = typename impl::remove_const_reference&lt;T2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; TR1 &gt;::exist||impl::container_traits&lt; TR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(binary_operation(minus_t(), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00180">180</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7846abe2d5f70e7f7762c35f437d4143"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class TR1  = typename impl::remove_const_reference&lt;T1&gt;::type, class TR2  = typename impl::remove_const_reference&lt;T2&gt;::type, typename std::enable_if&lt; impl::container_traits&lt; TR1 &gt;::exist||impl::container_traits&lt; TR2 &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(binary_operation(div_t(), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00210">210</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1feb67d99478836770118144be4cb417"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Maybe&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(impl::eval(f, std::declval&lt;T&gt;()))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++に合わせたbind演算子. Maybe m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b. </p>
<p><a class="anchor" id="maybe_bindop2"></a> C++では operator&gt;&gt;= と operator&lt;&lt;= は右結合であるため、処理が右端から順番に流れていく方が自然に記述できる（以下のサンプルコード参照）</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>適用する関数 </td></tr>
    <tr><td class="paramname">ma</td><td>Maybeオブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>関数適用結果が格納されたMaybeオブジェクト</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#acb90d9f305dbf9d6f7baf790daa54265" title="Haskell風のbind演算子. Maybe m => m a -> (a -> m b) -> m b. ">operator&gt;&gt;=(Maybe&lt;T&gt; const&amp; m, F const&amp; f)</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// using sig::operator&lt;&lt;=;  // required in non-sig namespace</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> m = Just&lt;int&gt;(1);</div>
<div class="line"><span class="keyword">auto</span> f = [&amp;](<span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> <a class="code" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">sig::Just</a>(v * 1.5); };  <span class="comment">// (a -&gt; m b)</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> mm = [&amp;](<span class="keywordtype">double</span> v){ <span class="keywordflow">return</span> <a class="code" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">Just</a>(std::to_string(v)); } &lt;&lt;= f &lt;&lt;= m;     <span class="comment">// suitable style for C++</span></div>
<div class="line"></div>
<div class="line">assert(<a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(*mm, std::to_string(4.5)));</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00241">241</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03aeb657956b0dfafff73410b9c85450"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;T1&gt;&amp;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maybeオブジェクトへの再代入を行う演算子 </p>
<p><a class="anchor" id="maybe_assignop"></a> 関数型言語では再代入は不可能な機能であるが、C++では無いと不便であるためこの関数を作成．<br />
Maybeオブジェクトへの再代入をJust, Nothingに関係なく統一的に記述することが目的</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Maybeオブジェクト </td></tr>
    <tr><td class="paramname">v</td><td>代入したい値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mへの参照</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// using sig::operator&lt;&lt;=;  // required in non-sig namespace</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> m = Just&lt;int&gt;(1);</div>
<div class="line"><span class="keyword">auto</span> n = <a class="code" href="namespacesig.html#a25cb201c09c499316f1bad72f8373a16">Nothing</a>();</div>
<div class="line"></div>
<div class="line">m &lt;&lt;= 2;</div>
<div class="line">n &lt;&lt;= 2;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> v1 = *m;    <span class="comment">// v1 == 2</span></div>
<div class="line"><span class="keywordtype">int</span> v2 = *n;    <span class="comment">// v2 == 2</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00273">273</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb90d9f305dbf9d6f7baf790daa54265"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">Maybe&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F const &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(impl::eval(f, std::declval&lt;T&gt;()))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Haskell風のbind演算子. Maybe m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b. </p>
<p><a class="anchor" id="maybe_bindop1"></a> C++では operator&gt;&gt;= は右結合であるため、連鎖させる際には明示的に()を使う必要あり（以下のサンプルコード参照）</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ma</td><td>Maybeオブジェクト </td></tr>
    <tr><td class="paramname">f</td><td>適用する関数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>関数適用結果が格納されたMaybeオブジェクト</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#a1feb67d99478836770118144be4cb417" title="C++に合わせたbind演算子. Maybe m => (a -> m b) -> m a -> m b. ">operator&lt;&lt;=(F const&amp; f, Maybe&lt;T&gt; const&amp; m)</a></dd></dl>
<div class="fragment"><div class="line"><span class="comment">// using sig::operator&gt;&gt;=;  // required in non-sig namespace</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> m = Just&lt;int&gt;(1);</div>
<div class="line"><span class="keyword">auto</span> f = [&amp;](<span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> <a class="code" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">sig::Just</a>(v * 1.5); };  <span class="comment">// (a -&gt; m b)</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> mm = (m &gt;&gt;= f) &gt;&gt;= [&amp;](<span class="keywordtype">double</span> v){ <span class="keywordflow">return</span> <a class="code" href="namespacesig.html#a1fafa5a56df7a8b5e949ee830ef2999c">Just</a>(std::to_string(v)); };   <span class="comment">// Haskell Style</span></div>
<div class="line"></div>
<div class="line">assert(<a class="code" href="namespacesig.html#a1f3f9d9c09ab0c38afaeafcdd66adb27">equal</a>(*mm, std::to_string(4.5)));</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="maybe_8hpp_source.html#l00212">212</a> of file <a class="el" href="maybe_8hpp_source.html">maybe.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa38045b9fb9540aafd0cec2c698921e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::Or </td>
          <td>(</td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00052">52</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c2b562fa40201017e304a89aaa2d3db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B1 , class... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::Or </td>
          <td>(</td>
          <td class="paramtype">B1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>conds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>可変長 or </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond,conds</td><td>bool変数 または operator boolが定義されたオブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>全引数に対してorを取った結果</dd></dl>
<div class="fragment"><div class="line">static_assert(!<a class="code" href="namespacesig.html#aa38045b9fb9540aafd0cec2c698921e6">Or</a>(<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="namespacesig.html#aa38045b9fb9540aafd0cec2c698921e6">Or</a>(<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00070">70</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c420275118d8f50ba11bb4edca967a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class ET  = typename impl::forward_element&lt;C&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::partition </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナから指定条件を満たす要素とそれ以外の要素とを分離する </p>
<p>(a -&gt; Bool) -&gt; [a] -&gt; ([a], [a])</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>条件判定を行う述語関数 (a -&gt; Bool) </td></tr>
    <tr><td class="paramname">list</td><td>データが格納されたコンテナ [a]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果のタプル ([a], [a])（コンテナ2つはlistと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 3&gt; data1{ 1, -3, 2 };  <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::unordered_set&lt;double&gt; data2{ 0, 1.1, -2.2, 3.3 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> pt1 = <a class="code" href="namespacesig.html#a5c420275118d8f50ba11bb4edca967a6">partition</a>([](<span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> v % 2; }, data1);</div>
<div class="line"><span class="keyword">auto</span> pt2 = <a class="code" href="namespacesig.html#a5c420275118d8f50ba11bb4edca967a6">partition</a>([](<span class="keywordtype">double</span> v){ <span class="keywordflow">return</span> v &lt; 0; }, data2);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> pt1_t = std::get&lt;0&gt;(pt1);  <span class="comment">// array&lt;int, 3&gt;{ 1, -3 }</span></div>
<div class="line"><span class="keyword">auto</span> pt1_f = std::get&lt;1&gt;(pt1);  <span class="comment">// array&lt;int, 3&gt;{ 2 }</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> pt2_t = std::get&lt;0&gt;(pt2);  <span class="comment">// std::unordered_set&lt;double&gt;{ -2.2 }</span></div>
<div class="line"><span class="keyword">auto</span> pt2_f = std::get&lt;1&gt;(pt2);  <span class="comment">// std::unordered_set&lt;double&gt;{ 0, 1.1, 3.3 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="filter_8hpp_source.html#l00114">114</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7062686052f3b43a56950645e37c1cc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::plus </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(binary_operation(plus_t(), std::forward&lt;T1&gt;(v1), std::forward&lt;T2&gt;(v2)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="binary__operation_8hpp_source.html#l00127">127</a> of file <a class="el" href="binary__operation_8hpp_source.html">binary_operation.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aecf29df3a5a8ad232497a9c0d41f2415"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sig::Print </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="others_8hpp_source.html#l00034">34</a> of file <a class="el" href="others_8hpp_source.html">others.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a95f0a25eb1e9135493cc96693ae477f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sig::Print </td>
          <td>(</td>
          <td class="paramtype">std::wstring const &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *const&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>L&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="others_8hpp_source.html#l00039">39</a> of file <a class="el" href="others_8hpp_source.html">others.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a75c8e07a98a11fe5b6b8daa9d0c436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class...&gt; class Container, typename std::enable_if&lt;!std::is_same&lt; T, std::wstring &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sig::Print </td>
          <td>(</td>
          <td class="paramtype">Container&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="others_8hpp_source.html#l00045">45</a> of file <a class="el" href="others_8hpp_source.html">others.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a664dfc3971cbf05de6eed3afcf0b7394"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class...&gt; class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sig::Print </td>
          <td>(</td>
          <td class="paramtype">Container&lt; std::wstring &gt; const &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *const&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>L&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="others_8hpp_source.html#l00051">51</a> of file <a class="el" href="others_8hpp_source.html">others.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74f9ef4103b6e5e2d6f961a6e23fd231"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class C  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::product </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> -&gt; typename impl::SameIf&lt;R, void, typename impl::container_traits&lt;C&gt;::value_type, R&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>総乗 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>戻り値型（桁あふれの可能性がある場合には明示的に指定する）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>総乗を求めたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec{2,3,4};</div>
<div class="line">std::set&lt;double&gt; set{1.1, 2.2, 3.3};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> p1 = <a class="code" href="namespacesig.html#a74f9ef4103b6e5e2d6f961a6e23fd231">product</a>(vec);      <span class="comment">// 24</span></div>
<div class="line"><span class="keywordtype">double</span> p2 = prodyct(set);   <span class="comment">// 7.986</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00131">131</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99f38478e2a527b8fa8642ae06bc7345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class C  = void, class Pred  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::product </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred const &amp;&#160;</td>
          <td class="paramname"><em>access_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::SameIf&lt;R, void, decltype(impl::eval(access_func, std::declval&lt;typename impl::container_traits&lt;C&gt;::value_type&gt;())), R&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>総乗 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>戻り値型（桁あふれの可能性がある場合には明示的に指定する）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>総乗を求めたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">access_func</td><td>コンテナの要素にアクセスし、そのオブジェクトから値を取得する関数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">array&lt;std::tuple&lt;int, int&gt;, 2&gt; ar{std::make_tuple(1, -2), std::make_tuple(3, -4)};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> p = <a class="code" href="namespacesig.html#a74f9ef4103b6e5e2d6f961a6e23fd231">product</a>(ar, [](std::tuple&lt;int, int&gt; <span class="keyword">const</span>&amp; e){ <span class="keywordflow">return</span> std::get&lt;1&gt;(e); });   <span class="comment">// 8</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00155">155</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39a17970188b8db0a2494d6da37ee1fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class CC  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::product_col </td>
          <td>(</td>
          <td class="paramtype">CC const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>行列の指定列の総乗 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>戻り値型（桁あふれの可能性がある場合には明示的に指定する）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>行列（ランダムアクセス可能な2次元コンテナ） </td></tr>
    <tr><td class="paramname">index</td><td>総乗を求めたい列番号</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">array&lt;array&lt;int, 3&gt;, 2&gt; mat{ { 1, 2, 3 }, { 4, 5, 6 } };    <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pr = <a class="code" href="namespacesig.html#a39a17970188b8db0a2494d6da37ee1fd">product_col</a>(mat, 1);   <span class="comment">// 10</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00202">202</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad68bf1bb02fbb4df60c56a6786559fdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class CC  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::product_row </td>
          <td>(</td>
          <td class="paramtype">CC const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>行列の指定行の総乗 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>戻り値型（桁あふれの可能性がある場合には明示的に指定する）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>行列（ランダムアクセス可能な2次元コンテナ） </td></tr>
    <tr><td class="paramname">index</td><td>総乗を求めたい行番号</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">array&lt;array&lt;int, 3&gt;, 2&gt; mat{ { 1, 2, 3 }, { 4, 5, 6 } };    <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> pr = <a class="code" href="namespacesig.html#ad68bf1bb02fbb4df60c56a6786559fdb">product_row</a>(mat, 1);   <span class="comment">// 120</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00180">180</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17b235dfeb8f4187bcc578d564589a4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class R  = typename container_traits&lt;C&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::read_line </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IfsSelector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; R(typename impl::SameIf&lt; R, std::string, std::string, std::wstring &gt;::type) &gt; const &amp;&#160;</td>
          <td class="paramname"><em>conv</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00302">302</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51c1019a172cbc0e8a6902c47179d035"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class R  = typename container_traits&lt;C&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::read_line </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; R(typename impl::SameIf&lt; R, std::string, std::string, std::wstring &gt;::type)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>conv</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00324">324</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ccaf18321471597128caf5188d63f4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class C  = std::vector&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::read_line </td>
          <td>(</td>
          <td class="paramtype">IfsSelector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>ifs</em></td><td>)</td>
          <td> -&gt; Just&lt;C&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00342">342</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab52d0046b9f7ac9ed91db7cc091747da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class C  = std::vector&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::read_line </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em></td><td>)</td>
          <td> -&gt; Just&lt;C&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00354">354</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5c60185cca68cde6203af4da6669b13b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class C  = std::vector&lt;R&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::read_line </td>
          <td>(</td>
          <td class="paramtype">FilepassStringC&#160;</td>
          <td class="paramname"><em>file_pass</em></td><td>)</td>
          <td> -&gt; Just&lt;C&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00365">365</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a006af42a5e66092c6e8709b3fedb78e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class RT  = typename container_traits&lt;C&gt;::value_type, typename std::enable_if&lt;!container_traits&lt; typename container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::read_num </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00377">377</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0037b2d7146782a93186d41cd55540b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CC , class RC  = typename container_traits&lt;CC&gt;::value_type, class RT  = typename container_traits&lt;RC&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::read_num </td>
          <td>(</td>
          <td class="paramtype">CC &amp;&#160;</td>
          <td class="paramname"><em>empty_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter1</em> = <code>&quot;\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter2</em> = <code>&quot;\n\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00406">406</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa03538ac6018ae7a9bf0e6e8ce26fe65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; container_traits&lt; C &gt;::exist &amp;&amp;!container_traits&lt; typename container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::read_num </td>
          <td>(</td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Just&lt;C&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00432">432</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c0b08a65c2bfa9e0c3bc1bc274fb8d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class TS  = impl::string_t&lt;S&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::regex_search </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename impl::Str2RegexSelector&lt; TS &gt;::regex const &amp;&#160;</td>
          <td class="paramname"><em>expression</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Maybe&lt;std::vector&lt;std::vector&lt;TS&gt;&gt;&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>std::regex_search のラッパ関数 </p>
<p>探索結果にアクセスしやすい様に二次元配列（vector&lt;vector&lt;string&gt;&gt;）に結果を格納している</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>探索対象の文字列 </td></tr>
    <tr><td class="paramname">expression</td><td>正規表現オブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>探索成功時には、result[マッチした箇所の順番][マッチ内の参照の順番. 0は全文, 1以降は参照箇所]を内包した<a class="el" href="sig_maybe.html">Maybe</a> を返す</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> src = <span class="stringliteral">&quot;test tes1 tes2&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> result= <a class="code" href="namespacesig.html#a8c0b08a65c2bfa9e0c3bc1bc274fb8d6">regex_search</a>(src, std::regex(<span class="stringliteral">&quot;tes(\\d)&quot;</span>));     <span class="comment">// [[tes1, 1], [tes2, 2]]</span></div>
<div class="line">assert(result[0][0] == <span class="stringliteral">&quot;tes1&quot;</span>);</div>
<div class="line">assert(result[1][0] == <span class="stringliteral">&quot;tes2&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="regex_8hpp_source.html#l00172">172</a> of file <a class="el" href="regex_8hpp_source.html">regex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a133944aec31d6c9e4dec7ff05e2deffb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::remove_all </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::call_traits&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::param_type&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナから指定した値を全削除 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>処理対象コンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">remove</td><td>削除したい値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>削除値が存在したか(bool)</dd></dl>
<div class="fragment"><div class="line">array&lt;std::string, 4&gt; data1{ <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;b&quot;</span> };</div>
<div class="line">std::vector&lt;int&gt; data2{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line">std::unordered_multiset&lt;int&gt; data3{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#a133944aec31d6c9e4dec7ff05e2deffb">remove_all</a>(data1, <span class="stringliteral">&quot;b&quot;</span>); <span class="comment">// true</span></div>
<div class="line"><a class="code" href="namespacesig.html#a133944aec31d6c9e4dec7ff05e2deffb">remove_all</a>(data2, 3);   <span class="comment">// true</span></div>
<div class="line"><a class="code" href="namespacesig.html#a133944aec31d6c9e4dec7ff05e2deffb">remove_all</a>(data3, 10);  <span class="comment">// false</span></div>
<div class="line"></div>
<div class="line">data1;      <span class="comment">// { &quot;a&quot;, &quot;c&quot; }</span></div>
<div class="line">data2;      <span class="comment">// { 1, 5, 0, 4, 0, 1 }</span></div>
<div class="line">data3;      <span class="comment">// { 1, 5, 3, 3, 0, 4, 0, 1, 3 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="remove_8hpp_source.html#l00148">148</a> of file <a class="el" href="remove_8hpp_source.html">remove.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae0de7db91a4969b0187b8b4c2380bd23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pred , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::remove_all_if </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>remove_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナから述語条件を満たす値を全削除 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>処理対象コンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">remove_pred</td><td>削除するか判断を行う関数オブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>削除値が存在したか</dd></dl>
<div class="fragment"><div class="line">std::list&lt;int&gt; data{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#ae0de7db91a4969b0187b8b4c2380bd23">remove_all_if</a>(data, [](<span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> v == 3; });</div>
<div class="line">data;       <span class="comment">// { 1, 5, 0, 4, 0, 1 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="remove_8hpp_source.html#l00173">173</a> of file <a class="el" href="remove_8hpp_source.html">remove.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23d67d01d1803dcb72538da634e29544"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class T  = typename impl::container_traits&lt;CR&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::remove_duplicates </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナの要素から重複した値を削除 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>処理対象コンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::map&lt;削除値, その個数&gt;</dd></dl>
<div class="fragment"><div class="line">array&lt;std::string, 4&gt; data1{ <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;b&quot;</span> };</div>
<div class="line">std::vector&lt;int&gt; data2{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line">std::unordered_multiset&lt;int&gt; data3{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> removed1 = <a class="code" href="namespacesig.html#a23d67d01d1803dcb72538da634e29544">remove_duplicates</a>(data1);   <span class="comment">// { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }</span></div>
<div class="line"><span class="keyword">auto</span> removed2 = <a class="code" href="namespacesig.html#a23d67d01d1803dcb72538da634e29544">remove_duplicates</a>(data2);   <span class="comment">// { 1, 5, 3, 0, 4 }</span></div>
<div class="line"><span class="keyword">auto</span> removed3 = <a class="code" href="namespacesig.html#a23d67d01d1803dcb72538da634e29544">remove_duplicates</a>(data3);   <span class="comment">// { 1, 5, 3, 0, 4 } 順不同</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="remove_8hpp_source.html#l00038">38</a> of file <a class="el" href="remove_8hpp_source.html">remove.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc8075c448a2814e18b1116fab36bc03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::remove_one </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename boost::call_traits&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::param_type&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナから指定した値を1つ削除 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>処理対象コンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">remove</td><td>削除したい値</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>削除値が存在したか(bool)</dd></dl>
<div class="fragment"><div class="line">array&lt;std::string, 4&gt; data1{ <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;b&quot;</span> };</div>
<div class="line">std::vector&lt;int&gt; data2{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line">std::unordered_multiset&lt;int&gt; data3{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#afc8075c448a2814e18b1116fab36bc03">remove_one</a>(data1, <span class="stringliteral">&quot;b&quot;</span>);     <span class="comment">// true</span></div>
<div class="line"><a class="code" href="namespacesig.html#afc8075c448a2814e18b1116fab36bc03">remove_one</a>(data2, 3);       <span class="comment">// true</span></div>
<div class="line"><a class="code" href="namespacesig.html#afc8075c448a2814e18b1116fab36bc03">remove_one</a>(data3, 10);      <span class="comment">// false</span></div>
<div class="line"></div>
<div class="line">data1;      <span class="comment">// { &quot;a&quot;, &quot;c&quot;, &quot;b&quot; }</span></div>
<div class="line">data2;      <span class="comment">// { 1, 5, 3, 0, 4, 0, 1, 3 }</span></div>
<div class="line">data3;      <span class="comment">// { 1, 5, 3, 3, 0, 4, 0, 1, 3 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="remove_8hpp_source.html#l00085">85</a> of file <a class="el" href="remove_8hpp_source.html">remove.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abfd1f54d7d2cae9f0311c31853bec4ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Pred , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::remove_one_if </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>remove_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナから述語条件を満たす値を1つ削除 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>処理対象コンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">remove_pred</td><td>削除するか判断を行う関数オブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>削除値が存在したか(bool)</dd></dl>
<div class="fragment"><div class="line">std::list&lt;int&gt; data{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#abfd1f54d7d2cae9f0311c31853bec4ae">remove_one_if</a>(data, [](<span class="keywordtype">int</span> v){ <span class="keywordflow">return</span> v == 3; });</div>
<div class="line">data;       <span class="comment">// { 1, 5, 3, 0, 4, 0, 1, 3 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="remove_8hpp_source.html#l00113">113</a> of file <a class="el" href="remove_8hpp_source.html">remove.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a28d02cbf89795ccd47382f5a7301f9bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class C  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::replicate </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; C
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>値を複製したコンテナを返す </p>
<p>uint -&gt; a -&gt; [a]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>複製する数 uint </td></tr>
    <tr><td class="paramname">value</td><td>複製する値 a</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナ [a]（defaultは std::vector）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> rep1 = <a class="code" href="namespacesig.html#a28d02cbf89795ccd47382f5a7301f9bf">replicate</a>(3, 3.14);                 <span class="comment">// std::vector&lt;double&gt;{ 3.14, 3.14, 3.14 }</span></div>
<div class="line"><span class="keyword">auto</span> rep2 = <a class="code" href="namespacesig.html#a28d02cbf89795ccd47382f5a7301f9bf">replicate</a>(2, std::string(<span class="stringliteral">&quot;rep&quot;</span>));   <span class="comment">// std::vector&lt;std::string&gt;{ &quot;rep&quot;, &quot;rep&quot; }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="list__deal_8hpp_source.html#l00033">33</a> of file <a class="el" href="list__deal_8hpp_source.html">list_deal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11b2c2d68fcc2274a922c3ebf2db3135"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::reverse </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> -&gt; typename impl::remove_const_reference&lt;C&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナの要素の順番を逆転させたコンテナを返す </p>
<p>[a] -&gt; [a]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>ソースとなるコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナ（コンテナはlistと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 4&gt; data1{ 1, 2, 3, 4 };        <span class="comment">// sig::array</span></div>
<div class="line">std::vector&lt;int&gt; data2{ 1, -3, 5, 2, 10 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> r1 = <a class="code" href="namespacesig.html#a11b2c2d68fcc2274a922c3ebf2db3135">reverse</a>(data1);               <span class="comment">// array&lt;int, 4&gt;{ 4, 3, 2, 1 }</span></div>
<div class="line"><span class="keyword">auto</span> r2 = <a class="code" href="namespacesig.html#a11b2c2d68fcc2274a922c3ebf2db3135">reverse</a>(std::move(data2));    <span class="comment">// std::vector&lt;int&gt;{ 10, 2, 5, -3, 1 }</span></div>
<div class="line"></div>
<div class="line">assert(data2.size() == 0);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="list__deal_8hpp_source.html#l00062">62</a> of file <a class="el" href="list__deal_8hpp_source.html">list_deal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab132bd55c25dd0e0ed148431369d89a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt;!impl::container_traits&lt; T &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_line </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename impl::FStreamSelector&lt; T &gt;::ofstream &amp;&#160;</td>
          <td class="paramname"><em>ofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ファイルへ1行ずつ保存 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>保存対象 </td></tr>
    <tr><td class="paramname">ofs</td><td>std::ofstream or std::wofstream </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="save_8hpp_source.html#l00059">59</a> of file <a class="el" href="save_8hpp_source.html">save.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a058e1b02b74bc59032bef4eadbf57834"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_line </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename impl::FStreamSelector&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::ofstream &amp;&#160;</td>
          <td class="paramname"><em>ofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルへ1行ずつまとめて保存 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>保存対象（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">ofs</td><td>std::ofstream or std::wofstream </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="save_8hpp_source.html#l00074">74</a> of file <a class="el" href="save_8hpp_source.html">save.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e3f10cfa5afdf6dab57ba4f1c775f0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt;!impl::container_traits&lt; T &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_line </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteMode&#160;</td>
          <td class="paramname"><em>open_mode</em> = <code>WriteMode::overwrite</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルへ1行ずつ保存 </p>
<p>file_passで指定したテキストファイルに、srcの内容を書き込み、最後に改行する．<br />
指定したファイルが存在しない場合、新たにファイルが作成される．</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>保存対象（非コンテナ） </td></tr>
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">open_mode</td><td>[option] 上書き(overwrite) or 追記(append)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line">std::string str{ <span class="stringliteral">&quot;str test&quot;</span> };</div>
<div class="line">std::wstring wstr{ L<span class="stringliteral">&quot;wstr test&quot;</span> };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#ab132bd55c25dd0e0ed148431369d89a8">save_line</a>(str, fpass);                      <span class="comment">// 上書き</span></div>
<div class="line"><a class="code" href="namespacesig.html#ab132bd55c25dd0e0ed148431369d89a8">save_line</a>(wstr, fpass, <a class="code" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d">WriteMode::append</a>);  <span class="comment">// 末尾に追記</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test.txt</span></div>
<div class="line">str test</div>
<div class="line">wstr test</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="save_8hpp_source.html#l00115">115</a> of file <a class="el" href="save_8hpp_source.html">save.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad613769c1571433e408ba0b8773cc6a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_line </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteMode&#160;</td>
          <td class="paramname"><em>open_mode</em> = <code>WriteMode::overwrite</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ファイルへ1行ずつまとめて保存 </p>
<p>file_passで指定したテキストファイルに、srcの内容をコンテナの1要素を1行として書き込む．<br />
指定したファイルが存在しない場合、新たにファイルが作成される．</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>保存対象（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">open_mode</td><td>[option] 上書き(overwrite) or 追記(append)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line">std::vector&lt;std::string&gt; data{ <span class="stringliteral">&quot;aaa&quot;</span>, <span class="stringliteral">&quot;bbb&quot;</span>, <span class="stringliteral">&quot;ccc&quot;</span> };</div>
<div class="line"><a class="code" href="namespacesig.html#ab132bd55c25dd0e0ed148431369d89a8">save_line</a>(data, fpass);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test.txt</span></div>
<div class="line">aaa</div>
<div class="line">bbb</div>
<div class="line">ccc</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="save_8hpp_source.html#l00155">155</a> of file <a class="el" href="save_8hpp_source.html">save.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3c5193ef23c23aa269a6b2bc6ed3b5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; container_traits&lt; C &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_line </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename impl::FStreamSelector&lt; typename container_traits&lt; C &gt;::value_type &gt;::ofstream &amp;&#160;</td>
          <td class="paramname"><em>ofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00208">208</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="addc3f0929bab231f9df1da232c03f250"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; impl::container_traits&lt; C &gt;::exist &amp;&amp;!impl::container_traits&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_num </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteMode&#160;</td>
          <td class="paramname"><em>open_mode</em> = <code>WriteMode::overwrite</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>数値列(ex:ベクトル)の保存 </p>
<p>file_passで指定したテキストファイルに、数値が格納されたコンテナsrcの各要素を文字列として書き込む．</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>保存対象（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">delimiter</td><td>数値間の区切り文字 </td></tr>
    <tr><td class="paramname">open_mode</td><td>[option] 上書き(overwrite) or 追記(append)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> list_num = std::list&lt;double&gt;{-1.1, -2.2, -3.3};</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> uset_num = std::unordered_set&lt;double&gt;{1.1, 2.2, 3.3};</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#addc3f0929bab231f9df1da232c03f250">save_num</a>(list_num, fpass, <span class="stringliteral">&quot;,&quot;</span>, <a class="code" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca77dced087fe638328cee93b9a263517b">WriteMode::overwrite</a>);</div>
<div class="line"><a class="code" href="namespacesig.html#addc3f0929bab231f9df1da232c03f250">save_num</a>(uset_num, fpass, <span class="stringliteral">&quot;\n&quot;</span>, <a class="code" href="namespacesig.html#a6076be9dec1b137e4e5b6651689f654ca9516dfb15f51c7ee19a4d46b8c0dbe1d">WriteMode::append</a>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test.txt</span></div>
<div class="line">-1.1,-2.2,-3.3</div>
<div class="line">1.1</div>
<div class="line">2.2</div>
<div class="line">3.3</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="save_8hpp_source.html#l00202">202</a> of file <a class="el" href="save_8hpp_source.html">save.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6126d24e606964ae51527f7c4a68b49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CC , typename std::enable_if&lt; impl::container_traits&lt; typename impl::container_traits&lt; CC &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_num </td>
          <td>(</td>
          <td class="paramtype">CC const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteMode&#160;</td>
          <td class="paramname"><em>open_mode</em> = <code>WriteMode::overwrite</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2次元配列の数値(ex:行列)を保存 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>保存対象の行列（<a class="el" href="sig_container.html">対応コンテナ</a> ) </td></tr>
    <tr><td class="paramname">file_pass</td><td>保存先のパス（ファイル名含む） </td></tr>
    <tr><td class="paramname">delimiter</td><td>数値間の区切り文字 </td></tr>
    <tr><td class="paramname">open_mode</td><td>[option] 上書き(overwrite) or 追記(append)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> dir = <a class="code" href="namespacesig.html#ab0015738aab7a37329d019d4e6cdd231">modify_dirpass_tail</a>( <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;./example&quot;</span>), <span class="keyword">true</span>);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> fpass = dir + <a class="code" href="sigutil_8hpp.html#a8c3b0abc6057fb8bcf1fcb3bd4ae456e">SIG_TO_FPSTR</a>(<span class="stringliteral">&quot;test.txt&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> array&lt;std::vector&lt;int&gt;, 3&gt; mat = {    <span class="comment">// sig::array</span></div>
<div class="line">    { 1, 2, 3 },</div>
<div class="line">    { 4, 5, 6, 7 },</div>
<div class="line">    { 8, 9 }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#addc3f0929bab231f9df1da232c03f250">save_num</a>(mat, fpass, <span class="stringliteral">&quot;,&quot;</span>);</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// test.txt</span></div>
<div class="line">1,2,3</div>
<div class="line">4,5,6,7</div>
<div class="line">8,9</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="save_8hpp_source.html#l00241">241</a> of file <a class="el" href="save_8hpp_source.html">save.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8076b49b677a978f418b45fc41c9e35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; container_traits&lt; C &gt;::exist &amp;&amp;!container_traits&lt; typename container_traits&lt; C &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_num </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>WriteMode::overwrite</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00260">260</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19874ad616ce905822fd376bdcbfb0f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CC , typename std::enable_if&lt; container_traits&lt; typename container_traits&lt; CC &gt;::value_type &gt;::exist &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::save_num </td>
          <td>(</td>
          <td class="paramtype">CC const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FilepassString const &amp;&#160;</td>
          <td class="paramname"><em>file_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>WriteMode::overwrite</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter1</em> = <code>&quot;\n&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter2</em> = <code>&quot;\n\n&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html#l00276">276</a> of file <a class="el" href="file__tmp_07save_00read_01num_08_8hpp_source.html">file_tmp(save,read num).hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef44f1b5b838fe9f968c3c60a95a396d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class TC  = typename std::common_type&lt;T1, T2&gt;::type, class C  = std::vector&lt;TC&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C sig::seqn </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>等差数列 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">st</td><td>初項 </td></tr>
    <tr><td class="paramname">d</td><td>公差 </td></tr>
    <tr><td class="paramname">n</td><td>項数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナ（defaultはstd::vector）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> as1 = <a class="code" href="namespacesig.html#aef44f1b5b838fe9f968c3c60a95a396d">seqn</a>(1, 2, 5);       <span class="comment">// std::vector&lt;int&gt;{ 1, 3, 5, 7, 9 }</span></div>
<div class="line"><span class="keyword">auto</span> as2 = <a class="code" href="namespacesig.html#aef44f1b5b838fe9f968c3c60a95a396d">seqn</a>(0, -1.1, 4);        <span class="comment">// std::vector&lt;double&gt;{ 0, -1.1, -2.2, -3.3 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="rest_8hpp_source.html#l00036">36</a> of file <a class="el" href="rest_8hpp_source.html">rest.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf7d35d5a05e2464005b5b4ddea0b3ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::shuffle </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナの要素をシャッフル </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>シャッフル対処のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">std::vector&lt;int&gt; data{ 1, 5, 3, 3, 0, 4, 0, 1, 3 };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#aaf7d35d5a05e2464005b5b4ddea0b3ff">shuffle</a>(data);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="shuffle_8hpp_source.html#l00029">29</a> of file <a class="el" href="shuffle_8hpp_source.html">shuffle.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92cba63dbbb129004b5f73a99c83141d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sig::shuffle </td>
          <td>(</td>
          <td class="paramtype">Cs &amp;...&#160;</td>
          <td class="paramname"><em>containers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>複数のコンテナの同じインデックスの要素を対応させながらシャッフル </p>
<p>先頭から、コンテナの中で最小のインデックスまでの範囲をシャッフルする．<br />
ex: c1[1, 2, 3, 4, 5], c2[1, 2, 3] -&gt; c1'[3, 1, 2, 4, 5], c2'[3, 1, 2]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containers</td><td>任意個のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">array&lt;double, 5&gt; data1{ 1.1, 2.2, 3.3, 4.4, 5.5 };</div>
<div class="line">std::vector&lt;int&gt; data2{ 1, 5, 3, -2 };</div>
<div class="line">std::list&lt;std::string&gt; data3{ <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span> }</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#aaf7d35d5a05e2464005b5b4ddea0b3ff">shuffle</a>(data1, data2, data3);       <span class="comment">// 各コンテナの[0]~[2]までが対応しながらシャッフルされる</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="shuffle_8hpp_source.html#l00076">76</a> of file <a class="el" href="shuffle_8hpp_source.html">shuffle.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc44bda76acdb1ae1ee8a72252ae2fee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sjis_to_utf16 </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::u16string 
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ShiftJIS -&gt; UTF-16. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Windows環境のみ</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列 </dd></dl>

<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00238">238</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa32eefbdbf2955fb1e971be030d1d499"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sjis_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::string
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ShiftJIS -&gt; UTF-8. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Windows環境のみ</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列 </dd></dl>

<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00281">281</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4930f26b351db7ea4dcb510d9c53119f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class T  = typename impl::sequence_container_traits&lt;CR&gt;::value_type, typename std::enable_if&lt; impl::has_random_access_iter&lt; CR &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sort </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(impl::eval(std::forward&lt;F&gt;(binary_op), std::declval&lt;T&gt;(), std::declval&lt;T&gt;()), void())
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>標準ソート関数のラッパ </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>ソート対象のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">binary_op</td><td>大小比較を行う関数オブジェクト</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">array&lt;double, 3&gt; data1{ 3.3, 1.1, -2.2 };   <span class="comment">// sig::array</span></div>
<div class="line">std::vector&lt;int&gt; data2{ 1, 5, 3, -2 };</div>
<div class="line">std::list&lt;int&gt; data3{ 1, 5, 3, -2 };</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#a4930f26b351db7ea4dcb510d9c53119f">sort</a>(data1, std::less&lt;double&gt;());</div>
<div class="line">data1;          <span class="comment">// { -2.2, 1.1, 3.3 }</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#a4930f26b351db7ea4dcb510d9c53119f">sort</a>(data2, std::less&lt;int&gt;());</div>
<div class="line">data2;          <span class="comment">// { -2, 1, 3, 5 }</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="namespacesig.html#a4930f26b351db7ea4dcb510d9c53119f">sort</a>(data3, std::greater&lt;int&gt;());</div>
<div class="line">data3;          <span class="comment">// { 5, 3, 1, -2 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="sort_8hpp_source.html#l00046">46</a> of file <a class="el" href="sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad870d6cd92e89746ca63158651629eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type, class T  = typename impl::static_container_traits&lt;CR&gt;::value_type, class D  = void, typename std::enable_if&lt; impl::has_random_access_iter&lt; CR &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sort </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(impl::eval(std::forward&lt;F&gt;(binary_op), std::declval&lt;T&gt;(), std::declval&lt;T&gt;()), void())
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sort_8hpp_source.html#l00061">61</a> of file <a class="el" href="sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae507cd57b9d1969c8a5f2dcae8e7b3c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class F , class T  = typename impl::container_traits&lt;typename impl::remove_const_reference&lt;C&gt;::type&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sort_with_index </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ソート前の位置を保持してソート </p>
<p>ex: [30, 50, -10, 0] -&gt; ([-10, 0, 30, 50], [2, 3, 0, 1])</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>ソート対象のコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">binary_op</td><td>大小比較を行う関数オブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;(ソート後のコンテナ), (ソート前のindexを記録したコンテナ)&gt;</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; cdata1{ 30, 50, -10, 0 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> swi1 = <a class="code" href="namespacesig.html#ae507cd57b9d1969c8a5f2dcae8e7b3c2">sort_with_index</a>(cdata1, std::less&lt;int&gt;());</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> sorted1 = std::get&lt;0&gt;(swi1);           <span class="comment">// { -10, 0, 30, 50 }</span></div>
<div class="line"><span class="keyword">auto</span> original_index1 = std::get&lt;1&gt;(swi1);   <span class="comment">// { 2, 3, 0, 1 }</span></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>TestInt{</div>
<div class="line">    std::vector&lt;int&gt; v;</div>
<div class="line">    <span class="keywordtype">bool</span> emp;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    TestInt() : v(), emp(true){}</div>
<div class="line">    TestInt(<span class="keywordtype">int</span> i) : v(1, i), emp(false){}</div>
<div class="line">    TestInt(TestInt <span class="keyword">const</span>&amp; s) : v(s.v), emp(false){}</div>
<div class="line">    TestInt(TestInt&amp;&amp; s) : v(std::move(s.v)), emp(false){ s.emp = <span class="keyword">true</span>; }</div>
<div class="line"></div>
<div class="line">    TestInt&amp; operator=(TestInt <span class="keyword">const</span>&amp; s){ v = s.v; emp = <span class="keyword">false</span>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line">    TestInt&amp; operator=(TestInt&amp;&amp; s){ v = std::move(s.v); emp = <span class="keyword">false</span>; s.emp = <span class="keyword">true</span>; <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>{ <span class="keywordflow">return</span> emp; }</div>
<div class="line">    <span class="keywordtype">int</span> value()<span class="keyword"> const</span>{ <span class="keywordflow">return</span> emp ? -1 : v[0]; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">array&lt;TestInt, 4&gt; data2{ 30, 50, -10, 0 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> swi2 = <a class="code" href="namespacesig.html#ae507cd57b9d1969c8a5f2dcae8e7b3c2">sort_with_index</a>(std::move(data2), [](TestInt <span class="keyword">const</span>&amp; l, TestInt <span class="keyword">const</span>&amp; r){ <span class="keywordflow">return</span> l.value() &gt; r.value(); });</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> sorted1 = std::get&lt;0&gt;(swi2);           <span class="comment">// { 50, 30, 0, -10 }</span></div>
<div class="line"><span class="keyword">auto</span> original_index1 = std::get&lt;1&gt;(swi2);   <span class="comment">// { 1, 0, 3, 2 }</span></div>
<div class="line">assert(data2[0].empty() &amp;&amp; data2[8].empty());   <span class="comment">// moved</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="sort_8hpp_source.html#l00131">131</a> of file <a class="el" href="sort_8hpp_source.html">sort.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4c8c4feeb72922c1e9075d8e26a1bc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class T_, class=std::allocator&lt; T_ &gt;&gt; class CSeq = std::vector, class S  = std::string, class TS  = impl::string_t&lt;S&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::split </td>
          <td>(</td>
          <td class="paramtype">S const &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">impl::string_t&lt; S &gt; const &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; CSeq&lt;TS&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>文字列(src)をある文字列(delimiter)を目印に分割する </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CSeq</td><td>returnされるシーケンスコンテナの種類</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>分割対象の文字列 </td></tr>
    <tr><td class="paramname">delimiter</td><td>分割の目印となる文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>分割後の文字列が格納されたシーケンスコンテナ</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> src = <span class="stringliteral">&quot; one,2, 参 &quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> spl = <a class="code" href="namespacesig.html#ac4c8c4feeb72922c1e9075d8e26a1bc5">split</a>(src, <span class="stringliteral">&quot;,&quot;</span>);     <span class="comment">// vector&lt;string&gt;{&quot; one&quot;, &quot;2&quot;, &quot; 参 &quot;}</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="manipulate_8hpp_source.html#l00040">40</a> of file <a class="el" href="manipulate_8hpp_source.html">manipulate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae01c7c755c15f366a01d1043544eec44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class T_, class=std::allocator&lt; T_ &gt;&gt; class CSeq = std::vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::split </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; CSeq&lt;std::string&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#ac4c8c4feeb72922c1e9075d8e26a1bc5" title="文字列(src)をある文字列(delimiter)を目印に分割する ">split(S const&amp; src, impl::string_t&lt;S&gt; const&amp; delimiter)</a> </dd></dl>

<p>Definition at line <a class="el" href="manipulate_8hpp_source.html#l00084">84</a> of file <a class="el" href="manipulate_8hpp_source.html">manipulate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf74ac7f74851ac3e9555169a3e3025d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class T_, class=std::allocator&lt; T_ &gt;&gt; class CSeq = std::vector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::split </td>
          <td>(</td>
          <td class="paramtype">wchar_t const *const&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t const *const&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; CSeq&lt;std::wstring&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#ac4c8c4feeb72922c1e9075d8e26a1bc5" title="文字列(src)をある文字列(delimiter)を目印に分割する ">split(S const&amp; src, impl::string_t&lt;S&gt; const&amp; delimiter)</a> </dd></dl>

<p>Definition at line <a class="el" href="manipulate_8hpp_source.html#l00096">96</a> of file <a class="el" href="manipulate_8hpp_source.html">manipulate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6a533edc2e7fb667d02c2d89bd2dfbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename std::enable_if&lt; std::is_floating_point&lt; typename impl::container_traits&lt; C &gt;::value_type &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::standardize </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>標準化(Standardization) </p>
<p>正規分布N(0, 1)になるように正規化<br />
standardize(C const&amp; data, int dummy = 0)ではなくこちらが呼び出されているかを確認するには、返り値をboolで受けるようにする</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>標準化を行いたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）．要素型は浮動小数点型であることが条件</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>なし</dd></dl>
<div class="fragment"><div class="line">array&lt;double, 5&gt; ar{ -3, -1, 0, 1, 3 }; <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> ck = <a class="code" href="namespacesig.html#ab6a533edc2e7fb667d02c2d89bd2dfbd">standardize</a>(ar);</div>
<div class="line">ar;             <span class="comment">// { -0.75, -0.25, 0, 0.25, 0.75 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00331">331</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f2aa381b8a0330d9810b8c625a556b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class C  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::standardize </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dummy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::container_traits&lt;C&gt;::template rebind&lt;R&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>標準化(Standardization) </p>
<p>正規分布N(0, 1)になるように正規化． <a class="el" href="namespacesig.html#ab6a533edc2e7fb667d02c2d89bd2dfbd" title="標準化(Standardization) ">standardize(C&amp; data)</a>ではなく明示的にこちらを呼び出す場合は、第2引数を指定</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>標準化を行いたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>標準化を行った結果</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 5&gt; ar1{  -3, -1, 0, 1, 3 };        <span class="comment">// sig::array</span></div>
<div class="line">array&lt;double, 5&gt; ar2{ 0, 1, 2, 3, 4 };              <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> stnd1 = <a class="code" href="namespacesig.html#ab6a533edc2e7fb667d02c2d89bd2dfbd">standardize</a>(ar1);          <span class="comment">// { -0.75, -0.25, 0, 0.25, 0.75}</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// 第2引数はダミー(ar2はconstでないため、オーバーロード解決でこの関数を呼び出すために必要)</span></div>
<div class="line"><span class="keyword">auto</span> stnd2 = <a class="code" href="namespacesig.html#ab6a533edc2e7fb667d02c2d89bd2dfbd">standardize</a>(ar2, 0);       <span class="comment">// { -1, -0.5, 0, 0.5, 1 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00363">363</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1e21be275ac0fa7858875b1832d50b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::str_to_wstr </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::wstring 
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>マルチバイト文字 -&gt; ワイド文字 </p>
<p>ex: Windows環境では Shift-JIS -&gt; UTF-16</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string str = <span class="stringliteral">&quot;aあ亜&quot;</span>;</div>
<div class="line"></div>
<div class="line">std::wstring wstr = <a class="code" href="namespacesig.html#ac1e21be275ac0fa7858875b1832d50b4">str_to_wstr</a>(str);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00116">116</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35d27eb84b02748727c2c57f8c797fc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class R  = typename impl::container_traits&lt;C&gt;::template rebind&lt;std::wstring&gt;, typename std::enable_if&lt; std::is_same&lt; typename impl::container_traits&lt; C &gt;::value_type, std::string &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::str_to_wstr </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; R
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>マルチバイト文字 -&gt; ワイド文字 </p>
<p>コンテナの全要素をまとめて変換 ex: Windows環境では Shift-JIS -&gt; UTF-16</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列が格納されたコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列が格納されたコンテナ</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#ac1e21be275ac0fa7858875b1832d50b4" title="マルチバイト文字 -> ワイド文字 ">str_to_wstr(std::string const&amp; src)</a></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; svec{<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;あ&quot;</span>, <span class="stringliteral">&quot;亜&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> wsvec = <a class="code" href="namespacesig.html#ac1e21be275ac0fa7858875b1832d50b4">str_to_wstr</a>(svec);     <span class="comment">// std::vector&lt;std::wstring&gt;</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00154">154</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f13a59ba58f7ba6759826a62cff3abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class C  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sum </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> -&gt; typename impl::SameIf&lt;R, void, typename impl::container_traits&lt;C&gt;::value_type, R&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>総和 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>戻り値型（桁あふれの可能性がある場合には明示的に指定する）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>総和を求めたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec{1,2,3};</div>
<div class="line">std::set&lt;double&gt; set{1.1, 2.2, 3.3};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> s1 = <a class="code" href="namespacesig.html#a8f13a59ba58f7ba6759826a62cff3abc">sum</a>(vec);      <span class="comment">// 6</span></div>
<div class="line"><span class="keywordtype">double</span> s2 = <a class="code" href="namespacesig.html#a8f13a59ba58f7ba6759826a62cff3abc">sum</a>(set);   <span class="comment">// 6.6</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00035">35</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b1ba8ea0b1c32132266462a39ebc629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class C  = void, class Pred  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sum </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred const &amp;&#160;</td>
          <td class="paramname"><em>access_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename impl::SameIf&lt;R, void, decltype(impl::eval(access_func, std::declval&lt;typename impl::container_traits&lt;C&gt;::value_type&gt;())), R&gt;::type
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>総和 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>戻り値型（桁あふれの可能性がある場合には明示的に指定する）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>総和を求めたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">access_func</td><td>コンテナの要素にアクセスし、そのオブジェクトから値を取得する関数</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">array&lt;std::tuple&lt;int, int&gt;, 2&gt; ar{std::make_tuple(1, -1), std::make_tuple(2, -2)};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> s = <a class="code" href="namespacesig.html#a8f13a59ba58f7ba6759826a62cff3abc">sum</a>(ar, [](std::tuple&lt;int, int&gt; <span class="keyword">const</span>&amp; e){ <span class="keywordflow">return</span> std::get&lt;1&gt;(e); });   <span class="comment">// -3</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00059">59</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27b16662097ae63858917af5d4a394e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class CC  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sum_col </td>
          <td>(</td>
          <td class="paramtype">CC const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>行列の指定列の総和 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>戻り値型（桁あふれの可能性がある場合には明示的に指定する）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>行列（ランダムアクセス可能な2次元コンテナ） </td></tr>
    <tr><td class="paramname">index</td><td>総和を求めたい列番号</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">array&lt;array&lt;int, 3&gt;, 2&gt; mat{ { 1, 2, 3 }, { 4, 5, 6 } };    <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> sc = <a class="code" href="namespacesig.html#a27b16662097ae63858917af5d4a394e1">sum_col</a>(mat, 1);   <span class="comment">// 7</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00106">106</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca23a120fd28afdef7ed55b08b10b157"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = void, class CC  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::sum_row </td>
          <td>(</td>
          <td class="paramtype">CC const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>行列の指定行の総和 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>戻り値型（桁あふれの可能性がある場合には明示的に指定する）</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>行列（ランダムアクセス可能な2次元コンテナ） </td></tr>
    <tr><td class="paramname">index</td><td>総和を求めたい行番号</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">array&lt;array&lt;int, 3&gt;, 2&gt; mat{ { 1, 2, 3 }, { 4, 5, 6 } };    <span class="comment">// sig::array</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> sr = <a class="code" href="namespacesig.html#aca23a120fd28afdef7ed55b08b10b157">sum_row</a>(mat, 1);   <span class="comment">// 15</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00084">84</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54e732db836fd6424e647a28235c88b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class CR  = typename impl::remove_const_reference&lt;C&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::take </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; CR
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コンテナの先頭からn個の要素を取り出す </p>
<p>uint -&gt; [a] -&gt; [a]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>先頭から順に取り出す要素の個数 </td></tr>
    <tr><td class="paramname">list</td><td>ソースとなるコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナ（listと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 4&gt; data1{ 1, 2, 3, 4 };        <span class="comment">// sig::array</span></div>
<div class="line">std::vector&lt;int&gt; data2{ 1, -3, 5, 2, 10 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> t1 = <a class="code" href="namespacesig.html#a54e732db836fd6424e647a28235c88b8">take</a>(2, data1);       <span class="comment">// array&lt;int, 4&gt;{ 1, 2 }</span></div>
<div class="line"><span class="keyword">auto</span> t2 = <a class="code" href="namespacesig.html#a54e732db836fd6424e647a28235c88b8">take</a>(3, data2);       <span class="comment">// std::vector&lt;int&gt; data2{ 1, -3, 5 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="list__deal_8hpp_source.html#l00225">225</a> of file <a class="el" href="list__deal_8hpp_source.html">list_deal.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a78cd3ddfbe0cd7bcc8d8903c004f9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CC , class T  = typename impl::container_traits&lt;typename impl::container_traits&lt;CC&gt;::value_type&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::to_matrix_ublas </td>
          <td>(</td>
          <td class="paramtype">CC const &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td> -&gt; matrix_u&lt;T&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STLのvectorの2次元配列 から ublas::matrix&lt;T&gt; へ変換 </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00174">174</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad9a2d548e457c7ad412bb13d81336524"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T  = typename impl::container_traits&lt;C&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::to_vector_ublas </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> -&gt; vector_u&lt;T&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>STLのvector から ublas::vector&lt;T&gt; へ変換 </p>

<p>Definition at line <a class="el" href="ublas_8hpp_source.html#l00161">161</a> of file <a class="el" href="ublas_8hpp_source.html">ublas.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5842dff6397dadbdb09a880b609d0ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint Index, class CT , class T  = typename std::tuple_element&lt;Index, typename impl::container_traits&lt;typename impl::remove_const_reference&lt;CT&gt;::type&gt;::value_type&gt;::type, class R  = std::vector&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::unzip </td>
          <td>(</td>
          <td class="paramtype">CT &amp;&amp;&#160;</td>
          <td class="paramname"><em>list_tuple</em></td><td>)</td>
          <td> -&gt; R
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>タプルのコンテナから、指定したindexのコンテナを取り出す </p>
<p>[(a, b, ...)] -&gt; [a0]</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>取り出すインデックス</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list_tuple</td><td>データが格納されたタプルのコンテナ [(a, b, ...)]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナ（コンテナはc_tupleと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;std::tuple&lt;int, std::string&gt;, 3&gt; data{  <span class="comment">// sig::array</span></div>
<div class="line">    std::make_tuple(1, <span class="stringliteral">&quot;a&quot;</span>),</div>
<div class="line">    std::make_tuple(2, <span class="stringliteral">&quot;b&quot;</span>),</div>
<div class="line">    std::make_tuple(3, <span class="stringliteral">&quot;c&quot;</span>)</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> uz1 = unzip&lt;0&gt;(data);  <span class="comment">// array&lt;int, 3&gt;{ 1, 2, 3 }</span></div>
<div class="line"><span class="keyword">auto</span> uz2 = unzip&lt;1&gt;(data);  <span class="comment">// array&lt;std::string, 3&gt;{ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="zip_8hpp_source.html#l00085">85</a> of file <a class="el" href="zip_8hpp_source.html">zip.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9514aaa85cf0247a5b08361d22723bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::unzip </td>
          <td>(</td>
          <td class="paramtype">CT &amp;&amp;&#160;</td>
          <td class="paramname"><em>c_tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>タプルのコンテナから、コンテナのタプルを作る </p>
<p>[(a, b, ...)] -&gt; ([a], [b], ...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c_tuple</td><td>データが格納されたタプルのコンテナ [(a, b, ...)]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>結果のコンテナを持つタプル（コンテナはc_tupleと同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;std::tuple&lt;int, std::string&gt;, 3&gt; data{  <span class="comment">// sig::array</span></div>
<div class="line">    std::make_tuple(1, <span class="stringliteral">&quot;a&quot;</span>),</div>
<div class="line">    std::make_tuple(2, <span class="stringliteral">&quot;b&quot;</span>),</div>
<div class="line">    std::make_tuple(3, <span class="stringliteral">&quot;c&quot;</span>)</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> uz = <a class="code" href="namespacesig.html#af5842dff6397dadbdb09a880b609d0ac">unzip</a>(data);  <span class="comment">// std::tuple&lt; array&lt;int, 3&gt;, array&lt;std::string, 3&gt; &gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> e1 = std::get&lt;0&gt;(uz);      <span class="comment">// array&lt;int, 3&gt;{ 1, 2, 3 }</span></div>
<div class="line"><span class="keyword">auto</span> e2 = std::get&lt;1&gt;(uz);      <span class="comment">// array&lt;std::string, 3&gt;{ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="zip_8hpp_source.html#l00139">139</a> of file <a class="el" href="zip_8hpp_source.html">zip.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7738904e0c2e47d2f7c9c4ad2627615"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::utf16_to_sjis </td>
          <td>(</td>
          <td class="paramtype">std::u16string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::string 
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-16 -&gt; ShiftJIS. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Windows環境のみ</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列 </dd></dl>

<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00258">258</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53b8e0198e9cc03be44a2c3cf3e94b37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::utf16_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">std::u16string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::string
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-16 -&gt; UTF-8. </p>
<dl class="section pre"><dt>Precondition</dt><dd>&lt;codecvt&gt;が必要</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列 </dd></dl>

<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00190">190</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae4ef55bd51e3af96c30503cc4ca51a12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">std::u32string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::string
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-32 -&gt; UTF-8. </p>
<dl class="section pre"><dt>Precondition</dt><dd>&lt;codecvt&gt;が必要</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列 </dd></dl>

<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00220">220</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03810f5be4d2bd5c311f2f4096a2076a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::utf8_to_sjis </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::string
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-8 -&gt; ShiftJIS. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Windows環境のみ</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列 </dd></dl>

<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00294">294</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa74b93ba472519ee0c0262921703c0ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::utf8_to_utf16 </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::u16string
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-8 -&gt; UTF-16. </p>
<dl class="section pre"><dt>Precondition</dt><dd>&lt;codecvt&gt;が必要</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列 </dd></dl>

<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00175">175</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e703b31c3c41197fd05b1403064e2a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::u32string
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UTF-8 -&gt; UTF-32. </p>
<dl class="section pre"><dt>Precondition</dt><dd>&lt;codecvt&gt;が必要</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列 </dd></dl>

<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00205">205</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef51ae2e65cfa57644f348690cb9efd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C1 , class... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::variadicZipWith </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>lists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>n引数高階関数 </p>
<p>(b -&gt; c -&gt; ... -&gt; a) -&gt; [b] -&gt; [c] -&gt; ... -&gt; [a] <br />
</p>

<p>Definition at line <a class="el" href="high__order_8hpp_source.html#l00023">23</a> of file <a class="el" href="high__order_8hpp_source.html">high_order.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac10ec1306d2bc98582867245269a87d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double sig::variance </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>分散 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>分散を求めたい値集合（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>計算結果</dd></dl>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec{1,2,3,4};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> var = <a class="code" href="namespacesig.html#aac10ec1306d2bc98582867245269a87d">variance</a>(vec); <span class="comment">// 1.25</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="basic__statistics_8hpp_source.html#l00241">241</a> of file <a class="el" href="basic__statistics_8hpp_source.html">basic_statistics.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad51d4efad46a8864eccad700cf61f5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sig::wstr_to_str </td>
          <td>(</td>
          <td class="paramtype">std::wstring const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; std::string 
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ワイド文字 -&gt; マルチバイト文字 </p>
<p>ex: Windows環境では UTF-16 -&gt; Shift-JIS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::wstring wstr(L<span class="stringliteral">&quot;aあ亜&quot;</span>);</div>
<div class="line"></div>
<div class="line">std::string str = <a class="code" href="namespacesig.html#aad51d4efad46a8864eccad700cf61f5e">wstr_to_str</a>(wstr);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00050">50</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d0946147a9e10e3efaee507d93b406e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class R  = typename impl::container_traits&lt;C&gt;::template rebind&lt;std::string&gt;, typename std::enable_if&lt; std::is_same&lt; typename impl::container_traits&lt; C &gt;::value_type, std::wstring &gt;::value &gt;::type *&amp;  = enabler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::wstr_to_str </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; R
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ワイド文字 -&gt; マルチバイト文字 </p>
<p>コンテナの全要素をまとめて変換 ex: Windows環境では UTF-16 -&gt; Shift-JIS</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>変換対象の文字列集合が格納されたコンテナ（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>変換後の文字列集合が格納されたコンテナ</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacesig.html#aad51d4efad46a8864eccad700cf61f5e" title="ワイド文字 -> マルチバイト文字 ">wstr_to_str(std::wstring const&amp; src)</a></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::wstring&gt; wsvec{L<span class="stringliteral">&quot;a&quot;</span>, L<span class="stringliteral">&quot;あ&quot;</span>, L<span class="stringliteral">&quot;亜&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> svec = <a class="code" href="namespacesig.html#aad51d4efad46a8864eccad700cf61f5e">wstr_to_str</a>(wsvec); <span class="comment">// std::vector&lt;std::string&gt;</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="convert_8hpp_source.html#l00090">90</a> of file <a class="el" href="convert_8hpp_source.html">convert.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7b35af07f2be1e569af810f7b8ac1f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B1 , class B2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sig::Xor </td>
          <td>(</td>
          <td class="paramtype">B1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>xor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond,conds</td><td>bool変数 または operator boolが定義されたオブジェクト</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xorの結果</dd></dl>
<div class="fragment"><div class="line">static_assert(!<a class="code" href="namespacesig.html#aa7b35af07f2be1e569af810f7b8ac1f2">Xor</a>(<span class="keyword">true</span>, <span class="keyword">true</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="namespacesig.html#aa7b35af07f2be1e569af810f7b8ac1f2">Xor</a>(<span class="keyword">true</span>, <span class="keyword">false</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(<a class="code" href="namespacesig.html#aa7b35af07f2be1e569af810f7b8ac1f2">Xor</a>(<span class="keyword">false</span>, <span class="keyword">true</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">static_assert(!<a class="code" href="namespacesig.html#aa7b35af07f2be1e569af810f7b8ac1f2">Xor</a>(<span class="keyword">false</span>, <span class="keyword">false</span>), <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="helper__modules_8hpp_source.html#l00092">92</a> of file <a class="el" href="helper__modules_8hpp_source.html">helper_modules.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a19163574c5211027fbf97f8933e113"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Cs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::zip </td>
          <td>(</td>
          <td class="paramtype">Cs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>lists</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>複数のコンテナから、タプルのコンテナを作る </p>
<p>[a] -&gt; [b] -&gt; ... -&gt; [(a, b, ...)] <br />
listsのいずれかの末尾に到達するまでタプルが作られる</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lists...</td><td>データが格納された複数のコンテナ [a],[b],...（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果のコンテナ [(a, b, ...)]（コンテナはlistsの[a]と同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 4&gt; data1{ 1, 2, 3, 4 };        <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; data2{ 1, -3, 5, 2, 10 };</div>
<div class="line"><span class="keyword">const</span> std::list&lt;double&gt; data3{ 1.1, -2.2, 3.3 };</div>
<div class="line"><span class="keyword">const</span> std::set&lt;std::string&gt; data4{ <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;aa&quot;</span>, <span class="stringliteral">&quot;aaa&quot;</span> };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> z = <a class="code" href="namespacesig.html#a1a19163574c5211027fbf97f8933e113">zip</a>(data1, data2, data3, data4);   <span class="comment">// array&lt; std::tuple&lt;int, int, double, std::string&gt;, 4&gt;</span></div>
<div class="line"></div>
<div class="line">uint size = z.size();   <span class="comment">// 3</span></div>
<div class="line"><span class="keyword">auto</span> e1 = z[1];     <span class="comment">// std::tuple&lt;int, int, double, std::string&gt;{ 2, -3, -2.2, &quot;aa&quot; }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="zip_8hpp_source.html#l00043">43</a> of file <a class="el" href="zip_8hpp_source.html">zip.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80784da68554a79015e7b28c4f3c8166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class C1 , class C2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sig::zipWith </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2引数高階関数 </p>
<p>(a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c] <br />
2つのコンテナのindexが対応する各要素に関数を適用し、結果を新たなコンテナに格納する</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>関数 (a -&gt; b -&gt; c) </td></tr>
    <tr><td class="paramname">list1</td><td>データが格納されたコンテナ [a]（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">list2</td><td>データが格納されたコンテナ [b]（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>処理結果のコンテナ [c]（コンテナはlist1と同じ種類）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;int, 3&gt; data1{ 1, -3, 5 };  <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::set&lt;double&gt; data2{ -2.2, 0 , 1.1, 3.3 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> r = <a class="code" href="namespacesig.html#a80784da68554a79015e7b28c4f3c8166">zipWith</a>([](<span class="keywordtype">int</span> a, <span class="keywordtype">double</span> b){ <span class="keywordflow">return</span> (a + b) / 2; }, data1, data2);</div>
<div class="line"></div>
<div class="line">r;      <span class="comment">// array&lt;double, 3&gt;{ -6, -1.5, 3.05 }</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="high__order_8hpp_source.html#l00088">88</a> of file <a class="el" href="high__order_8hpp_source.html">high_order.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aee91ea8ce00d3e85c52089138770fbff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_absolute_error.html">AbsoluteError</a> sig::absolute_error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="convergence_8hpp_source.html#l00033">33</a> of file <a class="el" href="convergence_8hpp_source.html">convergence.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4b505b4274b92cf40d4707249ce9856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_binary_distance.html">BinaryDistance</a> sig::binary_distance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>バイナリ距離を求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>データ点1の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">vec2</td><td>データ点2の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>データ点間の距離</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;uint, 4&gt; dot1{ 1, 1, 0, 0 };        <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;bool&gt; dot2{ <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span> };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> d = <a class="code" href="namespacesig.html#ac4b505b4274b92cf40d4707249ce9856">binary_distance</a>(dot1, dot2);</div>
<div class="line">d;      <span class="comment">// 0.75</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="binary__distance_8hpp_source.html#l00054">54</a> of file <a class="el" href="binary__distance_8hpp_source.html">binary_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac66ca30e3e48b1c84ad5581c96e26281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_canberra_distance.html">CanberraDistance</a> sig::canberra_distance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>キャンベラ距離を求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>データ点1の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">vec2</td><td>データ点2の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>データ点間の距離</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;uint, 5&gt; dot1{  -1, 0, 1, 2, 3 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;bool&gt; dot2{ 1, 1.5, 2, 2.5, 3 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> d = <a class="code" href="namespacesig.html#ac66ca30e3e48b1c84ad5581c96e26281">canberra_distance</a>(dot1, dot2);</div>
<div class="line">d;      <span class="comment">// 22 / 9.0</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="canberra__distance_8hpp_source.html#l00047">47</a> of file <a class="el" href="canberra__distance_8hpp_source.html">canberra_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0207655f912a6cacfffbfaf34b56f5d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_cosine_similarity.html">CosineSimilarity</a> sig::cosine_similarity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>コサイン類似度を求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>データ点1の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">vec2</td><td>データ点2の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>データ点間のコサイン距離</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>値域：[-1, 1]</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;uint, 5&gt; dot1{  -1, 0, 1, 2, 3 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;bool&gt; dot2{ 1, 1.5, 2, 2.5, 3 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> d = <a class="code" href="namespacesig.html#ac66ca30e3e48b1c84ad5581c96e26281">canberra_distance</a>(dot1, dot2);</div>
<div class="line">d;      <span class="comment">// 0.81649...</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="cosine__similarity_8hpp_source.html#l00049">49</a> of file <a class="el" href="cosine__similarity_8hpp_source.html">cosine_similarity.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a711206fafbfbbb458fbdeee6cb025915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sig::enabler</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a02c397bd9fe42a9d25e65d8de0444486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesig.html#a86e7da4764bbcbf7c70a300d401c431f">EuclideanDistance</a> sig::euclidean_distance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ユークリッド距離を求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>データ点1の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">vec2</td><td>データ点2の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>データ点間の距離</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;uint, 5&gt; dot1{  -1, 0, 1, 2, 3 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;bool&gt; dot2{ 1, 1.5, 2, 2.5, 3 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> d = <a class="code" href="namespacesig.html#a02c397bd9fe42a9d25e65d8de0444486">euclidean_distance</a>(dot1, dot2);</div>
<div class="line">d;          <span class="comment">// 7.5</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="minkowski__distance_8hpp_source.html#l00081">81</a> of file <a class="el" href="minkowski__distance_8hpp_source.html">minkowski_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abae91b25f01097a1034007df173aee16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_j_s___divergence.html">JS_Divergence</a> sig::js_divergence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JS情報量を求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist1</td><td>確率分布1（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">dist2</td><td>確率分布2（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dist1, dist2 の各要素は0以上の値 かつ 総和が 1</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>確率分布間の非類似度（値は<a class="el" href="sig_maybe.html">Maybe</a> で返される）</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>値域：[0, ∞)</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;double, 5&gt; dist1{ 0.2, 0.1, 0, 0.4, 0.3 };      <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;double&gt; dist2{ 0.1, 0.3, 0.1, 0.4, 0.1 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> m_js12 = <a class="code" href="namespacesig.html#abae91b25f01097a1034007df173aee16">js_divergence</a>(dist1, dist2)); <span class="comment">// js12 :: Maybe&lt;double&gt;</span></div>
<div class="line"><span class="keyword">auto</span> m_js21 = <a class="code" href="namespacesig.html#abae91b25f01097a1034007df173aee16">js_divergence</a>(dist2, dist1)); <span class="comment">// js21 :: Maybe&lt;double&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> js12 = <a class="code" href="namespacesig.html#a7f20e072bf9d74747a86b1e966cbc75b">fromJust</a>(m_js12);     <span class="comment">// 0.137744...</span></div>
<div class="line"><span class="keywordtype">double</span> js21 = *m_js21;              <span class="comment">// 0.137744...</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="_j_s__divergence_8hpp_source.html#l00065">65</a> of file <a class="el" href="_j_s__divergence_8hpp_source.html">JS_divergence.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a262388a714d056b15831fe341665101c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_k_l___divergence.html">KL_Divergence</a> sig::kl_divergence</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>KL情報量を求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist1</td><td>確率分布1（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">dist2</td><td>確率分布2（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>dist1の各要素は0以上の値 かつ dist2の各要素は正の値 かつ 総和が 1</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>確率分布間の非類似度（値は<a class="el" href="sig_maybe.html">Maybe</a> で返される）</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>値域：[0, ∞)</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;double, 5&gt; dist1{ 0.2, 0.1, 0, 0.4, 0.3 };      <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;double&gt; dist2{ 0.1, 0.3, 0.1, 0.4, 0.1 };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> m_kl12 = <a class="code" href="namespacesig.html#a262388a714d056b15831fe341665101c">kl_divergence</a>(dist1, dist2));     <span class="comment">// kl12 :: Maybe&lt;double&gt;</span></div>
<div class="line"><span class="comment">// auto m_kl21 = kl_divergence(dist2, dist1));  // error because dist1 has element whose value is 0</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> kl12 = <a class="code" href="namespacesig.html#a7f20e072bf9d74747a86b1e966cbc75b">fromJust</a>(m_kl12);     <span class="comment">// 0.51699...</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="_k_l__divergence_8hpp_source.html#l00062">62</a> of file <a class="el" href="_k_l__divergence_8hpp_source.html">KL_divergence.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbe87854e097c01e5262eebd1fd7ed18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesig.html#a2021fa0b889efd4766c666fa312e52c3">ManhattanDistance</a> sig::manhattan_distance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>マンハッタン距離を求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>データ点1の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">vec2</td><td>データ点2の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>データ点間の距離</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;uint, 5&gt; dot1{  -1, 0, 1, 2, 3 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;bool&gt; dot2{ 1, 1.5, 2, 2.5, 3 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> d = <a class="code" href="namespacesig.html#acbe87854e097c01e5262eebd1fd7ed18">manhattan_distance</a>(dot1, dot2);</div>
<div class="line">d;          <span class="comment">// 5</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="minkowski__distance_8hpp_source.html#l00062">62</a> of file <a class="el" href="minkowski__distance_8hpp_source.html">minkowski_distance.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeee341a411722c0b228c2df3dc604c15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_norm.html">Norm</a>&lt;1&gt; sig::norm_L1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>L1ノルムを求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>データ点1の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">vec2</td><td>[option] データ点2の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>データ点のノルム（vec2を指定時はデータ点間のノルム）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;uint, 5&gt; dot1{  -1, 0, 1, 2, 3 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;bool&gt; dot2{ 1, 1.5, 2, 2.5, 3 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> n = <a class="code" href="namespacesig.html#aeee341a411722c0b228c2df3dc604c15">norm_L1</a>(data1);</div>
<div class="line"><span class="keywordtype">double</span> nn = <a class="code" href="namespacesig.html#aeee341a411722c0b228c2df3dc604c15">norm_L1</a>(dot1, dot2);</div>
<div class="line">n;          <span class="comment">// 7</span></div>
<div class="line">nn;         <span class="comment">// 5</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="norm_8hpp_source.html#l00063">63</a> of file <a class="el" href="norm_8hpp_source.html">norm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7f5307120c0bb6a2dab899dbf675729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_norm.html">Norm</a>&lt;2&gt; sig::norm_L2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>L2ノルムを求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>データ点1の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">vec2</td><td>[option] データ点2の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>データ点のノルム（vec2を指定時はデータ点間のノルム）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;uint, 5&gt; dot1{  -1, 0, 1, 2, 3 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;bool&gt; dot2{ 1, 1.5, 2, 2.5, 3 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> n = <a class="code" href="namespacesig.html#ae7f5307120c0bb6a2dab899dbf675729">norm_L2</a>(data1);</div>
<div class="line"><span class="keywordtype">double</span> nn = <a class="code" href="namespacesig.html#ae7f5307120c0bb6a2dab899dbf675729">norm_L2</a>(dot1, dot2);</div>
<div class="line">n;          <span class="comment">// 3.87298...</span></div>
<div class="line">nn;         <span class="comment">// 2.73861...</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="norm_8hpp_source.html#l00082">82</a> of file <a class="el" href="norm_8hpp_source.html">norm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4f37903b93d965c46af91cfeddaa889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_max_norm.html">MaxNorm</a> sig::norm_max</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>最大ノルムを求める関数（関数オブジェクト） </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>データ点1の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ） </td></tr>
    <tr><td class="paramname">vec2</td><td>[option] データ点2の座標ベクトル（<a class="el" href="sig_container.html">対応コンテナ</a> ）</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>データ点のノルム（vec2を指定時はデータ点間のノルム）</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> array&lt;uint, 5&gt; dot1{  -1, 0, 1, 2, 3 };       <span class="comment">// sig::array</span></div>
<div class="line"><span class="keyword">const</span> std::list&lt;bool&gt; dot2{ 1, 1.5, 2, 2.5, 3 };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> n = <a class="code" href="namespacesig.html#ac4f37903b93d965c46af91cfeddaa889">norm_max</a>(data1);</div>
<div class="line"><span class="keywordtype">double</span> nn = <a class="code" href="namespacesig.html#ac4f37903b93d965c46af91cfeddaa889">norm_max</a>(dot1, dot2);</div>
<div class="line">n;          <span class="comment">// 3</span></div>
<div class="line">nn;         <span class="comment">// 2</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="norm_8hpp_source.html#l00125">125</a> of file <a class="el" href="norm_8hpp_source.html">norm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4905260658f296637729209011e8f2dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structsig_1_1_relative_error.html">RelativeError</a> sig::relative_error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="convergence_8hpp_source.html#l00048">48</a> of file <a class="el" href="convergence_8hpp_source.html">convergence.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacesig.html">sig</a></li>
    <li class="footer">Generated on Sat Dec 13 2014 12:19:26 for SigUtil by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
